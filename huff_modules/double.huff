#include "constants.huff"

// dup4 dup5
template <p1,p2>
#define DOUBLE_MAIN = takes(3) returns(3) {
    <p1> dup3 dup1
    mulmod
    // stack state: t1 z y x
    <p2> dup2
    // stack state: t1 p t1 z y x
    4 mul
    // stack state: t2 p t1 z y x
    dup2 dup1 dup1
    // stack state: p p p t2 p t1 z y x
    dup4 dup10
    // stack state: x t2 p p p t2 p t1 z y x
    mulmod
    // stack state: (x.t2) p p t2 p t1 z y x
    dup2 sub
    // stack state: t3 p p t2 p t1 z y x
    swap8
    // stack state: x p p t2 p t1 z y t3
    dup1 mulmod
    // stack state: x^2 p t2 p t1 z y t3
    3 mul
    // stack state: t4 p t2 p t1 z y t3 (t4 = 3x overloaded)
    dup2 dup2 dup1
    // stack state: t4 t4 p t4 p t2 p t1 z y t3
    mulmod
    // stack state: (t4^2) t4 p t2 p t1 z y t3
    dup9 dup1 add
    // stack state: 2t3 (t4^2) t4 p t2 p t1 z y t3
    add
    // x3 is 3x overloaded
    // stack state: x3 t4 p t2 p t1 z y t3 (x3 = 3x overloaded)
    
    swap8
    // stack state: t3 t4 p t2 p t1 z y x3
    dup9 add
    // stack state: (x3+t3) t4 p t2 p t1 z y x3 (x3+t3 = 4x overloaded)
    mulmod
    // stack state: y3' t2 p t1 z y x3
    swap3
    // stack state: t1 t2 p y3' z y x3
    mulmod
    // stack state: t1 y3' z y x3
    dup1 add
    // stack state: 2t1 y3' z y x3
    add
    // stack state: y3 z y x3
    // y3 is 3x overloaded
    swap2
    // stack state: y z y3 x3
    <p2>
    // stack state: p y z -y3 x3
    swap2
    // stack state: z y p -y3 x3
    dup1 add
    // stack state: 2z y p -y3 x3
    mulmod
    // stack state: -z3 -y3 x3
    <p1> sub
    // stack state: z3 -y3 x3
}

#define DOUBLE = takes(4) returns(4) {
    dup4 dup3 dup1
    mulmod
    // stack state: t1 z y x
    dup5 dup2
    // stack state: t1 p t1 z y x
    4 mul
    // stack state: t2 p t1 z y x (t2 = 4x overloaded)
    dup7 dup1 dup1
    // stack state: p p p t2 p t1 z y x
    dup4 dup10
    // stack state: x t2 p p p t2 p t1 z y x
    mulmod
    // stack state: (x.t2) p p t2 p t1 z y x
    dup10
    sub
    // stack state: t3 p p t2 p t1 z y x
    swap8
    // stack state: x p p t2 p t1 z y t3
    dup1 mulmod
    // stack state: x^2 p t2 p t1 z y t3
    3 mul
    // stack state: t4 p t2 p t1 z y t3 (t4 = 3x overloaded)
    dup9 dup2 dup1
    // stack state: t4 t4 p t4 p t2 p t1 z y t3
    mulmod
    // stack state: (t4^2) t4 p t2 p t1 z y t3
    dup9 dup1 add
    // stack state: 2t3 (t4^2) t4 p t2 p t1 z y t3
    add
    // stack state: x3 t4 p t2 p t1 z y t3 (x3 = 3x overloaded)
    swap8
    // stack state: t3 t4 p t2 p t1 z y x3
    dup9 add
    // stack state: (x3+t3) t4 p t2 p t1 z y x3 (x3+t3 = 4x overloaded)
    mulmod
    // stack state: y3' t2 p t1 z y x3
    swap3
    // stack state: t1 t2 p y3' z y x3
    mulmod
    // stack state: t1 y3' z y x3
    dup1 add
    // stack state: 2t1 y3' z y x3
    add
    // stack state: -y3 z y x3
    // we need to negate (-y3), which is 3x overloaded, so subtract from 3p
    65664728615517825666739217235771825266088933471893470988067113683935678625749
    sub
    // stack state: y3 z y x3
    swap2
    // stack state: y z y3 x3
    dup5
    // stack state: p y z y3 x3
    swap2
    // stack state: z y p y3 x3
    dup1 add
    // stack state: 2z y p y3 x3
    mulmod
}

// y x ... 
// p1 required when stack is size 2
// p2 stack size 3
// p3 stack size 4
// 3p stack size 8
/// @dev ok what the HELL is going on here? This is the third time I've had to unpick this so this time I'm documenting it
/// The point of this macro is to shave a few ```mulmod``` opcodes out of our algorithm to create a precomputed point table.
/// We ALWAYS know that the first point in our table is going to be affine, so we treat it as such to squeeze out a few opcodes.
/// Specifically - we perform our table operations on an isomorphism where the doubled point and the original point (2P, P) are
/// BOTH affine, even when they aren't. I.e. we do two things: double P and then re-scale P's x/y coordinates by 2P's z-coordinate.
/// HOWEVER, because P is affine, 2P's z-coordinate is just 2y. We already calculate x(2y)^{2} and y(2y)^{3} as part
/// of the doubling algorithm. So 'computing' these values is a waste because we already HAVE them!
/// So this algorithm computes a point doubling, shoves the result in <mx2> and <my2> (with the x-coordinate inverted)
/// and ALSO leaves y1 = 8y^{4} and x1 = 4xy^{2} on the stack.
template <mx2,my2,mz2,p1,p2,p3,3p>
#define DOUBLE_AFFINE_SHORT = takes(2) returns(2) {
    <p1> dup2 dup1 mulmod
    // stack state: t1 y x
    <p2> dup2 4 mul
    // stack state: t2 p t1 y x p (t2 = 4x overloaded)
    dup2 dup1 dup1 dup4 dup9 mulmod
    // stack state: zzx p p t2 p t1 y x
    swap7
    // stack state: x p p t2 p t1 y zzx
    dup1 mulmod 3 mul
    // stack state: t4 p t2 p t1 y zzx (t4 = 3x overloaded)
    dup2 dup2 dup1 mulmod
    // stack state: (t4^2) t4 p t2 p t1 y zzx
    dup8 dup4 sub dup1 add add
    // stack state: x3 t4 p t2 p t1 y t3 (x3 = 3x overloaded)
    <3p> sub
    dup1 <mx2> mstore
    // stack state: -x3 t4 p t2 p t1 y zzx p (x3 = 3x overloaded)
    dup8 add mulmod
    // stack state: y3' t2 p t1 y zzx (x3 = 3x overloaded)
    swap3 mulmod
    // stack state: zzzy y3' y zzx
    <p3> sub dup1 add
    // stack state: zzzy y3' y zzx (x3 = 3x overloaded)
    swap2
    // stack state: y y3' zzzy zzx
    dup1 add
    // stack state: z3 y3' zzzy zzx
    <mz2> mstore
    // stack state: y3' zzzy zzx
    dup2 add <my2> mstore
    // stack state: zzzy zzx
}

template <mx2,my2,mz2>
#define DOUBLE_AFFINE = takes(2) returns(2) {
    P() dup2 dup1 mulmod
    // stack state: t1 y x
    P() dup2 4 mul
    // stack state: t2 p t1 y x p (t2 = 4x overloaded)
    dup2 dup1 dup1 dup4 dup9 mulmod
    // stack state: zzx p p t2 p t1 y x
    swap7
    // stack state: x p p t2 p t1 y zzx
    dup1 mulmod 3 mul
    // stack state: t4 p t2 p t1 y zzx (t4 = 3x overloaded)
    dup2 dup2 dup1 mulmod
    // stack state: (t4^2) t4 p t2 p t1 y zzx
    dup8 dup4 sub dup1 add add
    // stack state: x3 t4 p t2 p t1 y t3 (x3 = 3x overloaded)
    3P() sub
    dup1 <mx2> mstore
    // stack state: -x3 t4 p t2 p t1 y zzx p (x3 = 3x overloaded)
    dup8 add mulmod
    // stack state: y3' t2 p t1 z y zzx (x3 = 3x overloaded)
    swap3 mulmod
    P() sub dup1 add
    // stack state: zzzy y3' y zzx (x3 = 3x overloaded)
    swap2
    // stack state: y y3' zzzy zzx
    dup1 add
    // stack state: z3 y3' zzzy zzx
    <mz2> mstore
    // stack state: y3' zzzy zzx
    dup2 add <my2> mstore
    // stack state: zzzy zzx
}

// stack state y p x z
template <mx2,my2,mz2>
#define PRECOMPUTE_TABLE_DOUBLE = takes(4) returns(3) {
    dup2
    dup1
    dup3 dup1// stack state: y y p p z y x p
    mulmod
    // stack state: t1 p y p x z
    dup2 dup2
    // stack state: t1 p t1 p y p x z
    4 mul
    // stack state: t2 p t1 p y p x z
    dup2 dup1
    // stack state: p p t2 p t1 p y p x z
    dup3 dup10
    // stack state: x t2 p p t2 p t1 p y p x z
    mulmod
    // stack state: (x.t2) p t2 p t1 p y p x z
    dup2
    sub
    // stack state: t3 p t2 p t1 p y p x z
    dup2 dup10 dup1 mulmod 3 mul
    // stack state: t4 t3 p t2 p t1 p y p x z
    swap1
    // stack state: t3 t4 p t2 p t1 p y p x z
    dup3 dup3 dup1 mulmod
    // stack state: t4^2 t3 t4 p t2 p t1 p y p x z
    dup2 dup1 add
    // stack state: 2t3 t4^2 t3 t4 p t2 p t1 p y p x z
    add
    // stack state: x3 t3 t4 p t2 p t1 p y p x z
    dup1 65664728615517825666739217235771825266088933471893470988067113683935678625749 sub
    <mx2> mstore // (storing -x3)
    // stack state: x3 t3 t4 p t2 p t1 p y p x z
    add
    // stack state: (x3 + t3) t4 p t2 p t1 p y p x z
    mulmod
    // stack state: y3' t2 p t1 p y p x z
    swap3
    // stack state: t1 t2 p y3' p y p x z
    mulmod
    // stack state: t1 y3' p y p x z
    dup1 add
    // stack state: 2t1 y3' p y p x z
    add
    // stack state: y3 p y p x z
    65664728615517825666739217235771825266088933471893470988067113683935678625749 sub
    <my2> mstore // (storing y3)
    // stack state: p y p x z
    dup1 dup6 dup1 add
    // stack state: 2z p p y p x z
    dup4 mulmod
    // stack state z3 p y p x z
    dup1 <mz2> mstore
    // final stack state z3 p y p x z
}

// stack state y x z
template <p1,p2,mx2,my2,mz2>
#define PRECOMPUTE_TABLE_DOUBLE_B = takes(4) returns(3) {
    <p1> dup2 dup1
    mulmod
    // stack state: t1 y x z
    <p2> dup2
    // stack state: t1 p t1 y x z
    4 mul
    // stack state: t2 p t1 y x z
    dup2 dup1
    // stack state: p p t2 p t1 y x z
    dup3 dup8
    // stack state: x t2 p p t2 p t1 y x z
    mulmod
    // stack state: (x.t2) p t2 p t1 y x z
    dup2
    sub
    // stack state: t3 p t2 p t1 y x z
    dup2 dup8 dup1 mulmod 3 mul
    // stack state: t4 t3 p t2 p t1 y x z
    swap1
    // stack state: t3 t4 p t2 p t1 y x z
    dup3 dup3 dup1 mulmod
    // stack state: t4^2 t3 t4 p t2 p t1 y x z
    dup2 dup1 add
    // stack state: 2t3 t4^2 t3 t4 p t2 p t1 y x z
    add
    // stack state: x3 t3 t4 p t2 p t1 y x z
    dup1 65664728615517825666739217235771825266088933471893470988067113683935678625749 sub
    <mx2> mstore // (storing -x3)
    // stack state: x3 t3 t4 p t2 p t1 y x z
    add
    // stack state: (x3 + t3) t4 p t2 p t1 y x z
    mulmod
    // stack state: y3' t2 p t1 y x z
    swap3
    // stack state: t1 t2 p y3' y x z
    mulmod
    // stack state: t1 y3' y x z
    dup1 add
    // stack state: 2t1 y3' y x z
    add
    // stack state: y3 p y x z
    65664728615517825666739217235771825266088933471893470988067113683935678625749 sub
    <my2> mstore // (storing y3)
    // stack state: y x z
    <p1> dup4 dup1 add
    // 2z p y x z
    dup3 mulmod
    // z3 y x z
    dup1 <mz2> mstore
    // final stack state z3 y x z
}

// stack state y x z
// <p1> at stack state 3 (dup4?)
// <p2> at stack state 4 (dup5?)
// <3p1> at stack state 11 (so dup13?)
// <3p2> at stacks state 4 (so dup6?)
template <mx2,my2,mz2,p1,p2,3p1,3p2>
#define PRECOMPUTE_TABLE_DOUBLE_C = takes(4) returns(3) {
    <p1> dup2 dup1
    mulmod
    // stack state: t1 y x z
    <p2> dup2
    // stack state: t1 p t1 y x z
    4 mul
    // stack state: t2 p t1 y x z
    dup2 dup1
    // stack state: p p t2 p t1 y x z
    dup3 dup8
    // stack state: x t2 p p t2 p t1 y x z
    mulmod
    // stack state: (x.t2) p t2 p t1 y x z
    dup2
    sub
    // stack state: t3 p t2 p t1 y x z
    dup2 dup8 dup1 mulmod 3 mul
    // stack state: t4 t3 p t2 p t1 y x z
    swap1
    // stack state: t3 t4 p t2 p t1 y x z
    dup3 dup3 dup1 mulmod
    // stack state: t4^2 t3 t4 p t2 p t1 y x z
    dup2 dup1 add
    // stack state: 2t3 t4^2 t3 t4 p t2 p t1 y x z
    add
    // stack state: x3 t3 t4 p t2 p t1 y x z
    dup1 <3p1> sub
    <mx2> mstore // (storing -x3)
    // stack state: x3 t3 t4 p t2 p t1 y x z
    add
    // stack state: (x3 + t3) t4 p t2 p t1 y x z
    mulmod
    // stack state: y3' t2 p t1 y x z
    swap3
    // stack state: t1 t2 p y3' y x z
    mulmod
    // stack state: t1 y3' y x z
    dup1 add
    // stack state: 2t1 y3' y x z
    add
    // stack state: y3 y x z
    <3p2> sub
    <my2> mstore // (storing y3)
    // stack state: y x z
    <p1> dup4 dup1 add
    // 2z p y x z
    dup3 mulmod
    // z3 y x z
    dup1 <mz2> mstore
    // final stack state z3 y x z
}