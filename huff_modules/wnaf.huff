#include "endomorphism.huff"
#include "constants.huff"

/**
 * @title windowed non-adjacent form macros
 *
 * Blah. I have two main algorithms to compute this and I'm leaving all of them in for now,
 * because I'm not sure which one is going to be the most efficient once I've optimized them.
 * The algos differ in how they determine how many 'bits' of the scalar to slice off when computing
 * a wnaf entry.
 *
 * The first (WNAF_CONSTANT__COMPUTE) uses bit-twiddling hacks to deterministically cleave off the optimal number of bits per cycle.
 * This seems quite elegant to me, but is a bit slow.
 *
 * The second (WNAF_JUMP_TABLE__COMPUTE) uses a jump table to directly jump to a subroutine that will *probably* identify the
 * optimal number of bits to cleave off from the scalar.
 * It's about 16 gas-per-wnaf-entry more efficient.
 *
 * On top of this madness I've implemented an alternative wnaf algorithm (COMPUTE_WNAFS_GREEDY) using the latter technique.
 * Instead of just identifying, for a given scalar, what each wnaf entry will be for a given bit index,
 * the algorithm will do the following:
 * 1. store the number of points that have non-zero wnaf entries for a given bit index
 * 2. instead of storing wnaf entries, we store pointers to the points in the precomputed lookup table
 *      that the wnaf entry corresponds to
 * This makes the wnaf algorithm rather bloated (~50 extra gas per non-zero wnaf entry).
 * However, it means that in our main loop, we don't have to iterate over wnaf entries,
 * because we can use another jump table to directly jump to an algorithm that has the exact
 * number of 'iterations' we need as a hardcoded bytecode sequence.
 * Removing the inner loop inside a 128-sized outer loop is worth bloating the wnaf algorithm.
 * In addition, we have more information at our disposal here to map from
 *   wnaf entry -> point in lookup table, so we might as well do it here instead of the main loop
 * (we know the memory location of the start of the lookup table. In the main loop, 
 *   we don't know what point we're working with so we need to compute this)
 *
 * This latter algorithm is still unoptimized (or at least, it feels unoptimized. Quite frankly it feels ugly),
 * so there's probably some more scope for improvements
 **/


/**
 * @title single iteration of width-non-adjacent-form algorithm
 * @dev Starting stack state = o w c_269 c_0x1fe0 c_16 c_mask
 * We have two 'slice' macros that do the same thing, but variables 'o' and 'w'
 * have reversed stack positions. This is to reduce the number of swap ops we use.
 * We use 4 constants in this macro, which we require on the stack instead of using PUSH ops.
 * This is to reduce the code size of this macro (PUSH is at least 2 bytes, other opcodes are a single byte)
 * @param o current memory offset to latest wnaf entry
 * @param w the scalar we're creating our wnaf from
 * @param c_269 the integer '269' (base 10), used in a lookup table
 * @param c_0x1fe0 the integer '1fe0' (base 16), used as a mask in our lookup table
 * @param c_16 the integer '16' (base 10), used to mutate ```w``` for next iteration cycle
 * @param c_mask 256-bit integer with all bits set high, except the least significant 5 bits
 **/
#define macro WNAF_CONSTANT__SLICE_A = takes(6) returns(6) {
    // Step 1: we need to isolate the least significant high bit of w
    // Can do this by taking w & -w
    // Instead of pushing '0' onto the stack (3 gas), we can get the 'return data size' of this EVM execution context.
    // As this contract doesn't call external contracts this will always be 0, and the opcode costs 2 gas.
    dup2 dup1 returndatasize sub and // stack state: w' o w

    // Step 2: use w' and the lookup table to calculate the bit index of the high bit in w'
    // We want to add this offset to 'o', which is our accumulated memory offset
    // So swap 'o' to the front of the stak in preparation
    swap1 // stack state: o w' w 269 0x1fe0 16 mask

    // We want to calculate w' mod 269; the literal needs to preceed w' so push it onto the stack
    // before duplicating w' (we don't consume w' as we need it later) and taking the modulus
    dup8 dup3 mod // stack state: (w' % 269) o w' w 269 0x1fe0 16 mask

    // use the result to byte-address the lookup table we stored
    // and mask off the byte corresponding to the bit index,
    // we use 0x1fe0 instead of 0xff because the table entry is shifted by 5 bits
    // this is because we use this value to address words in memory, so '1' needs to be '32'
    mload dup10 and // stack state: x o w' w

    // Tadaa, we have our index, no conditional branching in sight
    // We need this value to find the current byte-offset to store our wnaf, so add it straight to 'o'
    add // stack state: o' w' w

    // Now we know *where* to store the next wnaf section, we need to figure out *what* to store
    // Our scalar has an abritrary amount of leading 0 bits we need to remove, we can use w' as
    // our divisor without explicitly figuring out how many bits need to be culled
    swap2 // stack state: w w' o'
    div  // stack state: w o'

    // We want to store our wnaf entry at byte position 'o'.
    // We've divided w by the least significant bit in w, so we know that
    // our wnaf entry is in the least significant 5 bits of 'w'.
    // Instead of masking off the higher order bits, we can use mstore8
    // to store the least significant byte of 'w' at position 'o'.
    // We're storing multiple wnaf entries in a single EVM word, so it's cheaper
    // to mask off the unwanted 3 high bits per-evm-word, which we can do in the main loop
    dup1 dup3 mstore8 // stack state: w o' 269 0x1fe0 16 mask

    // We need to prepare our scalar for the next round of iteration
    // We've already stored the next 5 bits of the wnaf in our fragment at memory offset 'o'
    // So we need to zero out the 5 least significant bits of w so we don't double-count.

    // i.e. we calculate  w = (w & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0)
    // (the literal has every bit set high except the least significant 5)

    // There is one catch. If our wnaf fragment is negative (> 15), we need to add 2^{w} (32) to the scalar w.
    // This is because we're subtracting (32 - m) at this bit position.
    // So we need to add in 32 at the adjacent wnaf entry, but as that entry represents a value that is 2^{5} greater than this one,
    // we actually need to add 1, not 32. Clear as mud, yes?

    // The easiest way of doing this is by adding 16 into w.
    // If m > 15 then the 5th bit will be high w. So adding 16 will trigger an
    // overflow and add into the 6th bit. All lower order bits don't matter because we're about to mask them off
    dup9 add dup10 and // stack state: w o
}

// starting stack state w o 260 0x1fe0 16 mask
#define macro WNAF_CONSTANT__SLICE_B = takes(6) returns(6) {
    dup1 dup1 returndatasize sub and
    // w' w o x x 269 0x1fe0 16 mask
    dup8 dup2 mod
    // (w' % 269) w' w o 269 0x1fe0 16 mask
    mload dup10 and
    // x w' w o
    swap2
    // w w' x o
    div
    // w" x o
    swap2
    // o x w"
    add
    // o' w" 269 0x1fe0 16 mask
    dup2 dup10 add dup11 and
    // w''' o' w"
    swap2
    // w" o' w'''
    dup2
    // o' w" o' w'''
    mstore8
    // o' w'''
} // 72 gas

#define macro WNAF_CONSTANT__SET_TABLE = takes(0) returns(0) {
    0x00002da05a0dc2607b5a3ccdf1c286208d3b7bfa501cf60e1291e762b7664000 0x1f mstore
    0xa8ed5c7b871c1f7a79103fdd13d6240e24d2bad218879542c817996661801da0 0x3f mstore
    0xca49108d623c85fbb5c7201c3f3f83da95193d7045bfe39d2353f4364c84346e 0x5f mstore
    0x4f44f692c01aecd22898a467a9f574a2eee82e97ab998f869801a5200b1dd6c0 0x7f mstore
    0xebea73093e50a00d99e25b3cb1a60d1bcff5f267574008dc46ff58ffb3a3e4ba 0x9f mstore
    0xb87527f9417d8a306205d5a01f03b4fd458363340c744f36600ca86449d48ece 0xbf mstore
    0x6b6f77e50af6abd2fe2019db118cefd25728a6d8d3849847c14a01f59ef4c563 0xdf mstore
    0x0c4f000849aeab57cacbbe19b16fb706b3782121dec54c20098b2abdf156f341 0xff mstore
    0x1eac096a91333e89511e70f0c000000000000000000000000000000000000000 0x11f mstore
}

#define macro WNAF_CONSTANT__COMPUTE_SLICES = takes(2) returns(2) {
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
    WNAF_CONSTANT__SLICE_B()
    WNAF_CONSTANT__SLICE_A()
loop:
    WNAF_CONSTANT__SLICE_B()
    33 dup3 lt wnaf_end jumpi
    WNAF_CONSTANT__SLICE_A()
    dup1 32 lt loop jumpi
wnaf_end:
}

#define macro WNAF_CONSTANT__INIT = takes(0) returns(6) {
    // add wnaf table to memory
    WNAF_CONSTANT__SET_TABLE()
    // set up constants
    0x1000000000000000000000000000000000 // b
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 // mask b
    16 // 16 mask b
    0x1fe0 // 0x1fe0 16 mask b
    269 // 269 0x1fe0 16 mask b

    // compute calldata and memory offsets
    GET_NUMBER_OF_POINTS() // n
    dup1 dup1 add WNAF_START_LOCATION_MINUS_TWO() add       // m n
    swap1 0x06 shl        // s m 269 0x1fe0 16 mask b
}

#define macro FIND_FIRST_ENTRY = takes(0) returns(1) {
    WNAF_END_LOCATION_PLUS_32()  // m
search_next:
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 add
    dup1 mload iszero search_next jumpi
}


#define macro WNAF_CONSTANT__COMPUTE = takes(0) returns(0) {
    WNAF_CONSTANT__INIT()
wnaf_start:
    0x01
    dup2 calldataload ENDOMORPHISM() // k1 k2 v s m 269 0x1fe0 16 mask b
    dup10 or
    swap1 dup10 or // k2 k1 v s m 269
wnaf_continue:
    dup5 dup4 add     // get wnaf memory offset, and add 'v'
                      // (if k2, v = 1, increasing mem index by 1. if k1, v = 0)
    WNAF_CONSTANT__COMPUTE_SLICES() // w o k1 v s m 269 0x1fe0 16 mask b
    pop swap1                  // k1 o v s m 269 0x1fe0 16 mas kb
    0x01 dup4 sub swap3 wnaf_continue jumpi
    // x x x v s m 269 0x1fe0 16 mask b
    pop pop pop
    0x20 add    // s' m
    swap1 callvalue swap1 sub swap1 // s' m' // TODO optimize this
    dup1 calldatasize sub wnaf_start jumpi // s' m' 269 0x1fe0 16 mask b
    pop pop pop pop pop pop pop
}




#define macro WNAF_GREEDY__SIZE_OF_ENTRY = takes(0) returns(1) {
    GET_NUMBER_OF_POINTS() 0x04 mul 0x3e add
}

template<size_of_wnaf_entry_negated_1,size_of_wnaf_entry_negated_2>
#define macro WNAF_GREEDY__FIND_FIRST_ENTRY = takes(1) returns(1) {
    // starting pointer = start location + (127 * size of a wnaf entry)
    <size_of_wnaf_entry_negated_1> 0x07 shl WNAF_START_LOCATION() sub
    alternate_search_next:
        <size_of_wnaf_entry_negated_2> add
        dup1 mload iszero alternate_search_next jumpi
}

// (todo add more detail here)
// We want to, for a given bit index in our scalar multiplication, determine the following things:
// 1: How many points are we adding?
// 2: Where is the memory location of these points in our precomputed lookup table?
// Answering (1) adds a significant gas overhead, but allows us to use jump tables in our main loop,
// which is significantly more efficient than rote iteration
// i.e. instead of testing if each wnaf entry for a given bit index contains something and then add it into the sum,
// we can directly jump to a macro that will add every nonzero wnaf entry into the sum

// so...what if 'wnaf_pointer_total_increase' points 'o' to the current entry?
template<num_shifted_bits, num_shifted_bits_2, wnaf_pointer_total_increase, wnaf_pointer_base_increase>
#define macro WNAF_GREEDY__SLICE = takes(0) returns(0) {
    // w o k v s m
    dup1 <num_shifted_bits_2> shr 0x3e0 and dup7 add // w' w o k v s m
    dup3                                             // o w' w o k v s m 0_b 0_t 1_b 1_t 2_b 2_t 3_b 3_t 4_b 4_t
    <wnaf_pointer_total_increase> add swap3    // o w' w o'
    dup4 mload 0x02 add                             // n o w' w o'

    dup1 dup6 mstore                                // n o w' w o' k v s m 0_b 0_t 1_b 1_t
    <wnaf_pointer_base_increase>
    sub add            // o" w' w o'

    mstore                                          // w o
    <num_shifted_bits> shr 0x10 add                 // w" o
    dup1 WNAF_TABLE_MASK() and mload
    jump           //
}

// for odd wnaf entries we can get away with not adding wnaf_pointer_base_increase because it's zero
template<num_shifted_bits, wnaf_pointer_total_increase, wnaf_pointer_base_increase>
#define macro WNAF_GREEDY__SLICE_DEFAULT = takes(0) returns(0) {
    // w w o k v s m
    dup1 0x3e0 and dup7 add                         // w' w o
    dup3 <wnaf_pointer_total_increase> add swap3    // o w' w o'
    dup4 mload
    0x02 add                             // n o w' w o'
    dup1 dup6 mstore
    <wnaf_pointer_base_increase> sub add

    mstore                                          // w o'
    <num_shifted_bits> shr 0x10 add                 // w' o'
    dup1 WNAF_TABLE_MASK() and mload jump
}

#define jumptable WNAF_GREEDY__JUMP_TABLE {
    lsb_0 // 0 00000
    lsb_1 // 1 00001
    lsb_2 // 2 00010
    lsb_1 // 3 00011
    lsb_3 // 4 00100
    lsb_1 // 5 00101
    lsb_2 // 6 00110
    lsb_1 // 7 00111
    lsb_4  // 8 01000
    lsb_1  // 9 01001
    lsb_2  // 10 01010
    lsb_1  // 11 01011
    lsb_3  // 12 01100
    lsb_1  // 13 01101
    lsb_2  // 14 01110
    lsb_1  // 15 01111
}
// We expect the size of a WNAF entry to be the first item on the stack at this point
#define macro WNAF_GREEDY__COMPUTE = takes(1) returns(0) {

    __tablesize(WNAF_GREEDY__JUMP_TABLE) __tablestart(WNAF_GREEDY__JUMP_TABLE) 0x00 codecopy

    /* lsb_0 0x00 mstore // 0 00000
    lsb_1 0x20 mstore // 1 00001
    lsb_2 0x40 mstore // 2 00010
    lsb_1 0x60 mstore // 3 00011
    lsb_3 0x80 mstore // 4 00100
    lsb_1 0xa0 mstore // 5 00101
    lsb_2 0xc0 mstore // 6 00110
    lsb_1 0xe0 mstore // 7 00111
    lsb_4 0x100 mstore // 8 01000
    lsb_1 0x120 mstore // 9 01001
    lsb_2 0x140 mstore // 10 01010
    lsb_1 0x160 mstore // 11 01011
    lsb_3 0x180 mstore // 12 01100
    lsb_1 0x1a0 mstore // 13 01101
    lsb_2 0x1c0 mstore // 14 01110
    lsb_1 0x1e0 mstore // 15 01111 */
    /* lsb_5 0x200 mstore // 16 10000
    lsb_1 0x220 mstore // 17 10001
    lsb_2 0x240 mstore // 18 10010
    lsb_1 0x260 mstore // 19 10011
    lsb_3 0x280 mstore // 20 10100
    lsb_1 0x2a0 mstore // 21 10101
    lsb_2 0x2c0 mstore // 22 10110
    lsb_1 0x2e0 mstore // 23 10111
    lsb_4 0x300 mstore // 24 11000
    lsb_1 0x320 mstore // 25 11001
    lsb_2 0x340 mstore // 26 11010
    lsb_1 0x360 mstore // 27 11011
    lsb_3 0x380 mstore // 28 11100
    lsb_1 0x3a0 mstore // 29 11101
    lsb_2 0x3c0 mstore // 30 11110
    lsb_1 0x3e0 mstore // 31 11111 */
    // TODO: upgrade Huff compiler to support tables grafted into bytecode

    // Ok, wnaf algorithm. For every scalar multiplier we have, we want to 
    // convert to two half-length scalars by utilizing a curve endomorphism
    // (see ENDOMORPHISM for more details).
    // Once we have these two half-length scalars we need to compute their
    // windowed-non-adjacent-form representations.

    // set up our initial stack state...
    // LITERAL<WNAF_SIZE*0x40+0x100>() 0x100   // 5_base 5_total
    WNAF_TABLE_BITS() dup2 mul                 // d_b d
    dup2 3 mul dup3 WNAF_SIZE() mul add        // 3_t d_b d
    dup3 0x1e add dup2 sub                     // 3_b 3_t d_b d
    dup4 dup3 sub                              // 2_t 3_b 3_t d_b d
    dup5 dup3 sub                              // 2_b 2_t 3_b 3_t d_b d
    dup6 dup3 sub
    dup7 dup3 sub                              // 1_b 1_t 2_b 2_t 3_b 3_t d_b d
    dup8 dup3 sub                              // 0_t 1_b 1_t 2_b 2_t 3_b 3_t d_b d
    dup9 dup3 sub                              // 0_b 0_t 1_b 1_t 2_b 2_t 3_b 3_t d_b d
    // stack state: 0_b 0_t 1_b 1_t 2_b 2_t 3_b 3_t
    // Let's start by getting the number of scalars we have
    GET_NUMBER_OF_POINTS()         // n
    // Get offset to first entry of last point in precomputed lookup table
    dup1 dup1 add
    0x400 mul STRANGE_WNAF_SHIFTED_POINT_TABLE_OFFSET() add // 0x400 add (TODO: bit shifts?)

    // Point at start of calldatamap stored at end of memory table
    // (order is reversed)
    swap1 0x06 shl                // s m
    strange_wnaf_start:
        0x01
        dup2 calldataload ENDOMORPHISM() // k1 k2 v s m
        5 shl
        swap1 5 shl // k2 k1 v s m
    strange_wnaf_continue:    // k k' v s m
        // we need to subtract 1 from 'm' to reflect the fact that this point maps to a lookup table that is
        // directly preceding the previous point's lookup table in memory
        // (adding -400 saves us a swap opcode vs subtracting 1)
        // k k v s m 0_t 0_b 1_b 1_t 2_b 2_t 3_b 3_t d_b d
        swap4 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00 add swap4
        dup15 WNAF_SIZE() mul WNAF_START_LOCATION() sub   // o k k v s m
        swap1                   // w o k v s m
        dup1 WNAF_TABLE_MASK() and mload jump // and away we go?
    strange_wnaf_not_finished:  // w o k v s m 
        // we get here from lsb_0, so we just hit a patch of zeroes and still have more work to do.
        // Update our memory offset pointer to reflect the bits we're about to cleave away
        // w o k' v s m 0_t 0_b 1_b 1_t 2_b 2_t 3_b 3_t d_b
        swap1 dup15 add swap1
        // now let's clear away those zeroes and try again
        WNAF_TABLE_BITS() shr       // w o
        dup1 WNAF_TABLE_MASK() and mload
        jump
    // lsb_5:
    //     WNAF_GREEDY__SLICE<WNAF_SIZE+4,dup16,dup15>()
    lsb_4:  // w o x v s m 0_t 1_b 1_t 2_b 2_t 3_b 3_t
        WNAF_GREEDY__SLICE<WNAF_SIZE+3,3,dup16,dup16>()
    lsb_3:
        // WNAF_GREEDY__SLICE<WNAF_SIZE+2,dup12,dup11>()
        WNAF_GREEDY__SLICE<WNAF_SIZE+2,2,dup14,dup14>()
    lsb_2:
        WNAF_GREEDY__SLICE<WNAF_SIZE+1,1,dup12,dup12>()
    lsb_1: 
        WNAF_GREEDY__SLICE_DEFAULT<WNAF_SIZE,dup10,dup10>()
    lsb_0:
        // if we hit this location, our bit sequence is all zeroes.
        // This means 1 of two things:
        //   1. our scalar is empty, so we've converted everything into wnaf form
        //   2. we just hit a patch of zeroes, and we still have more higher-order bits to convert
        // So let's test for option 1. The least significant 5 bits are gunk at this point, so
        // we have work to do if the scalar is > 31 (0x1f)
        0x1f dup2 gt strange_wnaf_not_finished jumpi
        // 0x20 lt strange_wnaf_not_finished jumpi
        // If we hit this point, we're done with this scalar,
        // we check to see if we need to process another endomorphism scalar,
        // if not we jump back to the start of our loop to grab another scalar from calldata
        // we do this by decreasing 'v' by 0x01 and checking to see if original value is nonzero
        pop swap1                  // k1 o v s m

        0x01 dup4 sub swap3 strange_wnaf_continue jumpi
        // stack state: x x v s m
        // (clear away old wnaf junk and 'v')
        pop pop pop
        0x20 add    // s' m
        dup1 calldatasize sub strange_wnaf_start jumpi // s' m'
        pop pop
        pop pop pop pop pop pop pop pop
        pop
        // if we reach this point we can fall through to exit the macro
}

template<num_shifted_bits, wnaf_pointer_total_increase, wnaf_pointer_base_increase>
#define macro WNAF_JUMP_TABLE__SLICE = takes(0) returns(0) {
    // we reach this point via a jump table which maps the number of trailing zeroes in the wnaf
    // to a 'slice'. So we know how many bits we need to shift our wnaf down by.
    <num_shifted_bits> shr                      // w o
    // The wnaf now has the next bit sequence to be processed in the 6th bit index of the word.
    // This is so that we can directly address the jump table in memory
    // (each index occupies an evm word in memory, so if the next bit sequence is '101' this maps to '10100000',
    // which is 0xa0, which stores the jump label corresponding to wnaf bit sequence '101'.
    // This also neatly puts the *current* wnaf entry into the 5 least significant bits of the word.
    // This is the bit sequence that this macro needs to store in our wnaf table.
    // As for *where* to store that bit sequence, our offset variable 'o' contains the memory location of the current wnaf entry,
    // assuming that the bit sequence we're examining has no trailing zeroes.
    // Because we know how many bits we're reducing down by, we know the precise amount we need to add to this offset.

    // First, update the offset to point to the index of the next bit sequence
    dup1 dup3 <wnaf_pointer_total_increase> add // o' w w o
    // Then swap this with the old offset, and update the old offset to factor in the number of trailing zeroes in this bit sequence
    swap3 <wnaf_pointer_base_increase> add      // o'' w w o'
    // We can now directly call mstore8 using our wnaf word, as the wnaf entry is in the 5 least significant bits of the word.
    // (we can clean out the other 3 bits later in our main loop, where we can operate on one word at a time instead of one byte at a time)
    mstore8
    // Finally we need to update our wnaf. If the current bit sequence (m) is >= 16, it represents a negative entry.
    // i.e if m > 16, then we're subtracting (32 - m) at this bit index.
    // Our scalar is now off by a factor of 32, so we need to increase the next bit sequence by 1 to accomodate this
    // (the next bit sequence will represent a scalar that is 2^5 larger than this one, so 32 at this level equals 1 at the next level).
    // We can do this by adding 16 into our wnaf. If m >= 16 then the 5th bit will be high, so this will trigger
    // an integer overflow into the 6th bit
    // (which is actually the 1st bit of the next sequence because everything is shifted by 5 bits so we can use the wnaf as a lookup table index)
    0x10 add
    // Finally, mask off the next wnaf bit sequence and index our jump table
    dup1 WNAF_TABLE_MASK() and mload
    // and away we go again...
    jump
}

// alternative WNAF using a jump table.
#define macro WNAF_JUMP_TABLE__COMPUTE = takes(0) returns(0) {
    // what on earth?
    lsb_0 0x00 mstore // 0 00000
    lsb_1 0x20 mstore // 1 00001
    lsb_2 0x40 mstore // 2 00010
    lsb_1 0x60 mstore // 3 00011
    lsb_3 0x80 mstore // 4 00100
    lsb_1 0xa0 mstore // 5 00101
    lsb_2 0xc0 mstore // 6 00110
    lsb_1 0xe0 mstore // 7 00111
    lsb_4 0x100 mstore // 8 01000
    lsb_1 0x120 mstore // 9 01001
    lsb_2 0x140 mstore // 10 01010
    lsb_1 0x160 mstore // 11 01011
    lsb_3 0x180 mstore // 12 01100
    lsb_1 0x1a0 mstore // 13 01101
    lsb_2 0x1c0 mstore // 14 01110
    lsb_1 0x1e0 mstore // 15 01111
    lsb_5 0x200 mstore // 16 10000
    lsb_1 0x220 mstore // 17 10001
    lsb_2 0x240 mstore // 18 10010
    lsb_1 0x260 mstore // 19 10011
    lsb_3 0x280 mstore // 20 10100
    lsb_1 0x2a0 mstore // 21 10101
    lsb_2 0x2c0 mstore // 22 10110
    lsb_1 0x2e0 mstore // 23 10111
    lsb_4 0x300 mstore // 24 11000
    lsb_1 0x320 mstore // 25 11001
    lsb_2 0x340 mstore // 26 11010
    lsb_1 0x360 mstore // 27 11011
    lsb_3 0x380 mstore // 28 11100
    lsb_1 0x3a0 mstore // 29 11101
    lsb_2 0x3c0 mstore // 30 11110
    lsb_1 0x3e0 mstore // 31 11111
    // TODO: upgrade Huff compiler to support tables grafted into bytecode

    // Ok, wnaf algorithm. For every scalar multiplier we have, we want to 
    // convert to two half-length scalars by utilizing a curve endomorphism
    // (see ENDOMORPHISM for more details).
    // Once we have these two half-length scalars we need to compute their
    // windowed-non-adjacent-form representations.

    // So let's start by getting the number of scalars we have
        GET_NUMBER_OF_POINTS()         // n
        dup1 dup1 add WNAF_START_LOCATION_MINUS_TWO() add       // m n
        swap1 0x06 shl                // s m
    strange_wnaf_start:
        0x01
        dup2 calldataload ENDOMORPHISM() // k1 k2 v s m
        5 shl
        swap1 5 shl // k2 k1 v s m 269
    strange_wnaf_continue:
        dup5 dup4 add     // get wnaf memory offset, and add 'v' (1 or 0)
        swap1

        // (if k2, v = 1, increasing mem index by 1. if k1, v = 0)
        dup1 WNAF_TABLE_MASK() and mload jump // and away we go?

    lsb_5:  // w o
        WNAF_JUMP_TABLE__SLICE<WNAF_SIZE+4,WNAF_SIZE*0x20+0x80,0x80>()
    lsb_4:  // w o
        WNAF_JUMP_TABLE__SLICE<WNAF_SIZE+3,WNAF_SIZE*0x20+0x60,0x60>()
    lsb_3:
        WNAF_JUMP_TABLE__SLICE<WNAF_SIZE+2,WNAF_SIZE*0x20+0x40,0x40>()
    lsb_2:
        WNAF_JUMP_TABLE__SLICE<WNAF_SIZE+1,WNAF_SIZE*0x20+0x20,0x20>()
    lsb_1:
        WNAF_JUMP_TABLE__SLICE<WNAF_SIZE,WNAF_SIZE*0x20,0x00>()
    lsb_0:
        // if we hit this location, our bit sequence is all zeroes.
        // This means 1 of two things:
        //   1. our scalar is empty, so we've converted everything into wnaf form
        //   2. we just hit a patch of zeroes, and we still have more higher-order bits to convert
        // So let's test for option 1. The least significant 5 bits are gunk at this point, so
        // we have work to do if the scalar is > 31 (0x1f)
        0x1f dup2 gt strange_wnaf_not_finished jumpi

        // If we hit this point, we're done with this scalar,
        // we check to see if we need to process another endomorphism scalar,
        // if not we jump back to the start of our loop to grab another scalar from calldata
        pop swap1                  // k1 o v s m 269 0x1fe0 16 mas kb
        0x01 dup4 sub swap3 strange_wnaf_continue jumpi
        // x x x v s m 269 0x1fe0 16 mask b
        pop pop pop
        0x20 add    // s' m
        swap1 callvalue swap1 sub swap1 // s' m' // TODO optimize this
        dup1 calldatasize sub strange_wnaf_start jumpi // s' m'
        pop pop
        wnaf_end jump


    strange_wnaf_not_finished:  // w o
        // we get here from lsb_0, so we just hit a patch of zeroes and still have more work to do.
        // Update our memory offset pointer to reflect the bits we're about to cleave away
        swap1 LITERAL<WNAF_TABLE_BITS*0x20>() add swap1
        // now let's clear away those zeroes and try again
        WNAF_TABLE_BITS() shr       // w o
        dup1 WNAF_TABLE_MASK() and mload jump

    wnaf_end:
}
