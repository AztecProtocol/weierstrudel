#include "endomorphism.huff"

// starting stack state o w
#define WNAF_SLICE_A = takes(2) returns(1) {
    dup2 dup1 returndatasize sub and
    // w' o w
    swap1
    // o w' w
    269 dup3 mod
    // (w' % 269) o w' w
    mload 0x1fe0 and
    // x o w' w
    add
    // o' w' w
    swap2
    // w w' o'
    div
    // w o'
    dup1 dup3
    // o' w w o'
    mstore8
    // w o'
    16 add 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 and
    // w o'
}

// starting stack state w o
#define WNAF_SLICE_B = takes(2) returns(1) {
    dup1 dup1 returndatasize sub and
    // w' w o
    269 dup2 mod mload 0x1fe0 and
    // x w' w o
    swap2
    // w w' x o
    div
    // w" x o
    swap2
    // o x w"
    add
    // o' w"
    dup2 16 add 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 and
    // w''' o' w"
    swap2
    // w" o' w'''
    dup2
    // o' w" o' w'''
    mstore8
    // o' w'''
}
#define WNAF_SLICE = takes(2) returns(1) {
    // Step 1: we need to isolate the least significant high bit of w
    // Can do this by taking w & -w
    // Instead of pushing '0' onto the stack (3 gas), we can get the 'return data size' of this EVM execution context.
    // As this contract doesn't call external contracts this will always be 0, and the opcode costs 2 gas.
    dup1 dup1 returndatasize sub  // stack state: (0 - w) w w o
    and                 // w' w o

    // Step 2: use w' and the lookup table to calculate the bit index of the high bit in w'
    // We want to add this offset to 'o', which is our accumulated memory offset
    // So swap 'o' to the front of the stak in preparation
    swap2               // stack state: o w w'

    // We want to calculate w' mod 269; the literal needs to preceed w' so push it onto the stack
    // before duplicating w' (we don't consume w' as we need it later) and taking the modulus
    269
    dup4                // stack state: w' 269 o w w'
    mod                 // stack state: (w' % 269) o w w'

    mload               // use the result to byte-address the lookup table we stored
    0x1fe0 and          // and mask off the byte corresponding to the bit index
                        // mask by 0x1fe0 because the table entry is shifted by 5 bits
                        // because we're using this index to address a word in memory

    // Tadaa, we have our index, no conditional branching in sight
    // We only need this value to find the right byte-offset to store our wnaf, so add it straight to 'o'
    add             // stack state: o w w'

    // Now we know *where* to store the next wnaf section, we need to figure out *what* to store
    // Our scalar has an abritrary amount of leading 0 bits we need to remove, we can use w' as
    // our divisor without explicitly figuring out how many bits need to be culled
    swap2            // get w' in front of w on the stack. Needs two swap ops. Disgusting!
    swap1            // stack state: w w' o
    div              // w o

    // To get the actual scalar value we want to store at this bit index, we usually would take
    // w mod 2^(window size). We hardcode a window size of 5, so this can be simplified to (w & 31)

    // Instead, we just store the least significant *byte* at our calculated memory offset, using mstore8.
    // Our wnaf window has width 5, so we want to store the least 5 signficant bits of w.
    // HOWEVER, it's cheaper to mask this off when we *load* the wnaf, because we're storing
    // multiple wnaf entries in an evm word, so we can mask off at the word-level and not the byte-level
    dup1             // copy w. Stack state: w w o
    dup3             // copy o. Stack state: o m w o
    mstore8          // store our wnaf fragment // w o

    // Right, what's left now? We need to prepare our scalar for the next round of iteration
    // We've already stored the next 5 bits of the wnaf in our fragment at memory offset 'o'
    // So we need to zero out the 5 least significant bits so we don't double-count.
    // We *could* divide down by 2^5, but div operations are expensive and we don't save anything as
    // our lookup table shenanigans divide down the scalar by the required amount in the next cycle.

    // So instead we just calculate (w & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0)
    // (the literal has every bit set high except the least significant 5)

    // There is one catch. If our wnaf fragment is negative (> 15), we need to add 2^{w} (32) to the scalar.
    // This is because we're subtracting (32 - m) at this bit position.
    // We want to set it up so that the next wnaf entry will contain an additional factor of 32.

    // The easiest way of doing this is by adding 16 into w.
    // If m > 15 then the 5th bit will be high w. So adding 16 will trigger an
    // overflow and add into the 6th bit. All lower order bits don't matter because we're about to mask them off
    16 add
    // Now all that's left is to mask out the lowest 5 bits
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 and

    // And we're done with one round of iteration.
}

#define SET_WNAF_TABLE = takes(0) returns(0) {
    0x00002da05a0dc2607b5a3ccdf1c286208d3b7bfa501cf60e1291e762b7664000 0x1f mstore
    0xa8ed5c7b871c1f7a79103fdd13d6240e24d2bad218879542c817996661801da0 0x3f mstore
    0xca49108d623c85fbb5c7201c3f3f83da95193d7045bfe39d2353f4364c84346e 0x5f mstore
    0x4f44f692c01aecd22898a467a9f574a2eee82e97ab998f869801a5200b1dd6c0 0x7f mstore
    0xebea73093e50a00d99e25b3cb1a60d1bcff5f267574008dc46ff58ffb3a3e4ba 0x9f mstore
    0xb87527f9417d8a306205d5a01f03b4fd458363340c744f36600ca86449d48ece 0xbf mstore
    0x6b6f77e50af6abd2fe2019db118cefd25728a6d8d3849847c14a01f59ef4c563 0xdf mstore
    0x0c4f000849aeab57cacbbe19b16fb706b3782121dec54c20098b2abdf156f341 0xff mstore
    0x1eac096a91333e89511e70f0c000000000000000000000000000000000000000 0x11f mstore
}

// expects w o to be on stack
#define WNAF = takes(2) returns(1) {
    // righto, what are we doing here?
    // the standard way to calculate a window-non adjacent form is to
    // divide the scalar down by 2 until the scalar is odd (and keep track of the bit index as we divide down)
    // we then take the value of the scalar mod 2^(window size)
    // this is our wnaf value for the calculated bit position , after accounting for negative values
    // we then subtract off the wnaf from the scalar (if the wnaf is negative this will increase the scalar),
    // divide by 2 again and keep going until our scalar = 0

    // But that sounds like a lot of effort, so we take the lazy approach
    // instead of dividing down by 2 until we find an odd bit, it's much cheaper to calculate the bit index of the least significant high bit
    // by using some bitwise shenanigans and a lookup table

    // this removes a lot of conditional jumps that we would otherwise need and is MUCH cheaper
    // we hard-code for a window size of 5; this resulting wnaf has a hamming weight of 1/6
    // i.e. using the divide-by-2 method results in aimlessly dividing by 2 5/6th of the time,
    // and only doing anything interesting in 1/6 of all iterations
    
    // Once we isolate the least significant high bit, we can then use that as the denominator to
    // divide down our scalar, instead of iteratively dividing by 2

    // To start with, we need a lookup table.
    // The most efficient way I can come up with for getting the index of the least significant high bit
    // is to isolate the lsb and take the result of that value modulo 269.
    // 269 is relatively prime to 2^n for all n from 0 to 256, resulting in 256 unique integers < 269.
    // We then convert these into the correct bit positions by using a lookup table

    // This algorithm creates a wnaf structure where each bit index is offset by 32 bytes in memory.
    // This is so that we can concatenate the same wnaf entry from multiple points into a single 32-byte word
    // Becaues of this our lookup table does not map (value mod 269) to bit index positions, but instead
    // maps to bit index positions * 32.

    // For example, if the next non-zero bit index is 4, then mload(2^4 mod 269) & 0x1fe0 = 4*32 = 128

    // I think it's possible to use the isolated bit as a divisor against some constant to get
    // 256 unique integers, but I think that technique requires a mask in addition to a lookup table

    // Anyhow, here's the table. It's calculated in 'js_snippets/find_lookup_table.js'
    // We use (scalar mod 269) directly to byte-address memory. Beause the evm
    // loads data in 32-byte machine words, we need to offset the table by 31 bytes so that
    // the relevant lookup value is in the least significant byte (shifted left by 5 bits) and can be masked off
    // TODO: We could store this table directly in code and use CODECOPY to save in memory
    // Would be cheaper but requires modifying the bytecode directly which is...eugh, can't be bothered 

    // Call WNAF_SLICE 19 times. 127-bit random scalars take between 19-24 iterations of the loop
// TODO, assert > 0
loop:
    WNAF_SLICE()
    dup1 loop jumpi
}


#define ENDO_WNAF_FIXED_B = takes(2) returns(1) {
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
    WNAF_SLICE_B()
    WNAF_SLICE_A()
loop:
    WNAF_SLICE_B()
    33 dup3 lt wnaf_end jumpi
    WNAF_SLICE_A()
    dup1 32 lt loop jumpi
wnaf_end:
}

#define ENDO_WNAF_FIXED = takes(2) returns(1) {
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
    WNAF_SLICE()
loop:
    WNAF_SLICE()
    dup1 32 lt loop jumpi
}

#define ENDO_WNAF = takes(0) returns(1) {
    0x0 calldataload
    ENDOMORPHISM()
    0x140 swap1
    WNAF()
    pop pop 0x141 swap1
    WNAF()
}





