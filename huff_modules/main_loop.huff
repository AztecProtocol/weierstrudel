#include "constants.huff"
#include "wnaf.huff"
#include "precompute_table.huff"
#include "double.huff"
#include "add.huff"

// w i p t1 p z1 -y1 x1 p 2p 3p table
/// @dev use wnaf table to get the memory location of a point, and update wnaf table
#define GET_P2_LOCATION = takes(0) returns(0) {
    returndatasize mload      // w
    // we want to get a byte index of our wnaf table that is non-zero
    // we don't want to iterate over every byte, because that's slow!
    // instead we isolate the least significant set bit of t.
    // We know that non-zero wnaf entries are aligned at byte boundaries because we stored them via mstore8
    // we also know that every wnaf entry is odd. Ipso facto, if we isolate the least significant bit of w
    // then that bit corresponds to the first bit in a byte that contains a non-zero wnaf entry

    dup1 returndatasize sub               // -w w
    dup2 and                    // b w
    // next up, is to calculate the index of the byte in 'b' that is nonzero.
    // In WNAF, we used a lookup table to calculate this, but because we are testing the byte index here and not the bit index we can be more efficient.
    // (credit to Recmo Bloemen for showing me this trick).
    // use b as the divisor against literal 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f.
    // because b only has one bit set, and that bit is the 1st bit of a byte, this acts like a bit-shift operation on the literal.
    // which will place our desired byte index in the least significant byte, which we can mask off
    0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f div 0xff and // x w

    // we want to clear the wnaf entry at byte index 'b' (for future iterations)
    returndatasize dup2 mstore8 // that'll do it.

    // now what we have our wnaf byte index, we can use it for two purposes
    // 1: access the relevant byte in 'w' that contains our wnaf entry
    // 2: calculate the memory offset where our point is stored
    // point lookup tables take 32 words of memory per point (excluding endomorphism)
    // which equals precisely 1kb (0x400)
    swap1 // w x
    dup2 0x400 mul // o w x
    swap2 byte 0x8a add // points start at 0x1060, so we need to add 0x1040 into result

    0x20 mul add // o_x

    dup1 0x20 add // o_y o_x
}

// b w p t1 p z1 -y1 x1 p 2p 3p table
/// @dev use wnaf table to get the memory location of a point, and update wnaf table
#define GET_P2_LOCATION_LOOP = takes(0) returns(0) {
    returndatasize mload      // w
    // we want to get a byte index of our wnaf table that is non-zero
    // we don't want to iterate over every byte, because that's slow!
    // instead we isolate the least significant set bit of t.
    // We know that non-zero wnaf entries are aligned at byte boundaries because we stored them via mstore8
    // we also know that every wnaf entry is odd. Ipso facto, if we isolate the least significant bit of w
    // then that bit corresponds to the first bit in a byte that contains a non-zero wnaf entry

    dup1 returndatasize sub               // -w w
    dup2 and                    // b w
    // next up, is to calculate the index of the byte in 'b' that is nonzero.
    // In WNAF, we used a lookup table to calculate this, but because we are testing the byte index here and not the bit index we can be more efficient.
    // (credit to Recmo Bloemen for showing me this trick).
    // use b as the divisor against literal 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f.
    // because b only has one bit set, and that bit is the 1st bit of a byte, this acts like a bit-shift operation on the literal.
    // which will place our desired byte index in the least significant byte, which we can mask off
    dup13 div 0xff and // x w

    // we want to clear the wnaf entry at byte index 'b' (for future iterations)
    returndatasize dup2 mstore8 // that'll do it.

    // now what we have our wnaf byte index, we can use it for two purposes
    // 1: access the relevant byte in 'w' that contains our wnaf entry
    // 2: calculate the memory offset where our point is stored
    // point lookup tables take 32 words of memory per point (excluding endomorphism)
    // which equals precisely 1kb (0x400)
    swap1 // w x
    dup2 0x0a shl // mul // o w x
    // dup2 0x400 mul // o w x
    swap2 byte 0x8a add // points start at 0x1060, so we need to add 0x1040 into result

    0x05 shl add // o_x

    dup1 0x20 add // o_y o_x
}
// (+2 not skip)
// (-13 if skip)
template <wnafLocation>
#define MAIN_LOOP_SLICE_ALT = takes(10) returns(10) {
    DOUBLE_MAIN<dup5, dup6>()
    <wnafLocation> mload dup1 add_points_start jumpi
    pop add_skip jump
add_points_start:
    dup10 and returndatasize mstore
add_points_next:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
jumpdest
    returndatasize mload add_points_next jumpi
add_skip:
}

template <wnafLocation>
#define MAIN_LOOP_SLICE = takes(10) returns(10) {
    DOUBLE_MAIN<dup5, dup6>()
    <wnafLocation> mload iszero add_skip jumpi
    <wnafLocation> mload dup10 and returndatasize mstore
add_points_next:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
jumpdest
    returndatasize mload add_points_next jumpi
add_skip:
}

/*
// z y x i p 2p 3p table wnafmask
template <wnafLocation, additionJumpdest>
#define MAIN_LOOP_SLICE_SMALL = takes(10) returns(10) {

    DOUBLE_MAIN<dup5, dup6>()
    finished_addition 0x20 mstore
    <wnafLocation> mload dup1 <additionJumpdest> jumpi
    pop
finished_addition:
}

#define ADDITION_FUNCTION = takes(0) returns(0) {
    dup10 and returndatasize mstore
    add_next:
        ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
        returndatasize mload add_next jumpi
    0x20 mload jump
}

template <w>
#define MAIN_LOOP_STATIC_SMALL = takes(0) returns(0) {
    start jump
addition:
    ADDITION_FUNCTION()
start:
    0x20 dup5 0x1140 sub div    // delta z y x i p 2p 3p
    __codesize(MAIN_LOOP_SLICE_SMALL<0x1000>) mul // skip z y x i p 2p 3p
    hmm add 0x20 mstore
    dup4 ADDITION_FUNCTION()

hmm:
    MAIN_LOOP_SLICE_SMALL<w+0xfc, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xfa, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xf8, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xf6, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xf4, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xf2, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xf0, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xee, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xec, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xea, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xe8, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xe6, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xe4, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xe2, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xe0, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xde, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xdc, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xda, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xd8, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xd6, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xd4, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xd2, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xd0, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xce, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xcc, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xca, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xc8, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xc6, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xc4, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xc2, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xc0, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xbe, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xbc, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xba, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xb8, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xb6, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xb4, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xb2, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xb0, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xae, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xac, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xaa, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xa8, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xa6, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xa4, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xa2, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xa0, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x9e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x9c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x9a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x98, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x96, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x94, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x92, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x90, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x8e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x8c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x8a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x88, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x86, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x84, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x82, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x80, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x7e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x7c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x7a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x78, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x76, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x74, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x72, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x70, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x6e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x6c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x6a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x68, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x66, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x64, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x62, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x60, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x5e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x5c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x5a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x58, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x56, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x54, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x52, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x50, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x4e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x4c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x4a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x48, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x46, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x44, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x42, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x40, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x3e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x3c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x3a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x38, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x36, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x34, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x32, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x30, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x2e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x2c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x2a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x28, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x26, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x24, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x22, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x20, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x1e, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x1c, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x1a, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x18, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x16, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x14, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x12, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0x10, addition>()
    MAIN_LOOP_SLICE_SMALL<w+0xe0, addition()
    MAIN_LOOP_SLICE_SMALL<w+0xc0, addition()
    MAIN_LOOP_SLICE_SMALL<w+0xa0, addition()
    MAIN_LOOP_SLICE_SMALL<w+0x80, addition()
    MAIN_LOOP_SLICE_SMALL<w+0x60, addition()
    MAIN_LOOP_SLICE_SMALL<w+0x40, addition()
    MAIN_LOOP_SLICE_SMALL<w+0x20, addition()
    MAIN_LOOP_SLICE_SMALL<w+0x00, addition()
}
*/
template <w>
#define MAIN_LOOP_STATIC = takes(0) returns(0) {
    // now let's figure out where we need to jump to
    // so if i = 0x1140 then we start at the very top
    // and if i = 0x160 we skip straight to the end
    // z y x i p 2p 3p
    // dup4 0x00 mstore 0x20 0x00 return
    0x20 dup5 0x1140 sub div   // jump distance
    // 0x00 mstore 0x20 0x00 return
    // 0x00 mstore 0x20 0x00 return
    // __codesize(MAIN_LOOP_SLICE<0x1000>) 0x00 mstore 0x20 0x00 return
    __codesize(MAIN_LOOP_SLICE<0x1000>) mul
    hmm add jump
    // // first loop iteration
    // DOUBLE_MAIN<dup5, dup6>()
    // <wStart> mload dup1 add_points_start jumpi
    // pop add_skip jump
jumpdest
    dup10 and returndatasize mstore
add_points_next:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
hmm:
    returndatasize mload add_points_next jumpi
jumpdest

    MAIN_LOOP_SLICE<w+0xfc0>()
    MAIN_LOOP_SLICE<w+0xfa0>()
    MAIN_LOOP_SLICE<w+0xf80>()
    MAIN_LOOP_SLICE<w+0xf60>()
    MAIN_LOOP_SLICE<w+0xf40>()
    MAIN_LOOP_SLICE<w+0xf20>()
    MAIN_LOOP_SLICE<w+0xf00>()
    MAIN_LOOP_SLICE<w+0xee0>()
    MAIN_LOOP_SLICE<w+0xec0>()
    MAIN_LOOP_SLICE<w+0xea0>()
    MAIN_LOOP_SLICE<w+0xe80>()
    MAIN_LOOP_SLICE<w+0xe60>()
    MAIN_LOOP_SLICE<w+0xe40>()
    MAIN_LOOP_SLICE<w+0xe20>()
    MAIN_LOOP_SLICE<w+0xe00>()
    MAIN_LOOP_SLICE<w+0xde0>()
    MAIN_LOOP_SLICE<w+0xdc0>()
    MAIN_LOOP_SLICE<w+0xda0>()
    MAIN_LOOP_SLICE<w+0xd80>()
    MAIN_LOOP_SLICE<w+0xd60>()
    MAIN_LOOP_SLICE<w+0xd40>()
    MAIN_LOOP_SLICE<w+0xd20>()
    MAIN_LOOP_SLICE<w+0xd00>()
    MAIN_LOOP_SLICE<w+0xce0>()
    MAIN_LOOP_SLICE<w+0xcc0>()
    MAIN_LOOP_SLICE<w+0xca0>()
    MAIN_LOOP_SLICE<w+0xc80>()
    MAIN_LOOP_SLICE<w+0xc60>()
    MAIN_LOOP_SLICE<w+0xc40>()
    MAIN_LOOP_SLICE<w+0xc20>()
    MAIN_LOOP_SLICE<w+0xc00>()
    MAIN_LOOP_SLICE<w+0xbe0>()
    MAIN_LOOP_SLICE<w+0xbc0>()
    MAIN_LOOP_SLICE<w+0xba0>()
    MAIN_LOOP_SLICE<w+0xb80>()
    MAIN_LOOP_SLICE<w+0xb60>()
    MAIN_LOOP_SLICE<w+0xb40>()
    MAIN_LOOP_SLICE<w+0xb20>()
    MAIN_LOOP_SLICE<w+0xb00>()
    MAIN_LOOP_SLICE<w+0xae0>()
    MAIN_LOOP_SLICE<w+0xac0>()
    MAIN_LOOP_SLICE<w+0xaa0>()
    MAIN_LOOP_SLICE<w+0xa80>()
    MAIN_LOOP_SLICE<w+0xa60>()
    MAIN_LOOP_SLICE<w+0xa40>()
    MAIN_LOOP_SLICE<w+0xa20>()
    MAIN_LOOP_SLICE<w+0xa00>()
    MAIN_LOOP_SLICE<w+0x9e0>()
    MAIN_LOOP_SLICE<w+0x9c0>()
    MAIN_LOOP_SLICE<w+0x9a0>()
    MAIN_LOOP_SLICE<w+0x980>()
    MAIN_LOOP_SLICE<w+0x960>()
    MAIN_LOOP_SLICE<w+0x940>()
    MAIN_LOOP_SLICE<w+0x920>()
    MAIN_LOOP_SLICE<w+0x900>()
    MAIN_LOOP_SLICE<w+0x8e0>()
    MAIN_LOOP_SLICE<w+0x8c0>()
    MAIN_LOOP_SLICE<w+0x8a0>()
    MAIN_LOOP_SLICE<w+0x880>()
    MAIN_LOOP_SLICE<w+0x860>()
    MAIN_LOOP_SLICE<w+0x840>()
    MAIN_LOOP_SLICE<w+0x820>()
    MAIN_LOOP_SLICE<w+0x800>()
    MAIN_LOOP_SLICE<w+0x7e0>()
    MAIN_LOOP_SLICE<w+0x7c0>()
    MAIN_LOOP_SLICE<w+0x7a0>()
    MAIN_LOOP_SLICE<w+0x780>()
    MAIN_LOOP_SLICE<w+0x760>()
    MAIN_LOOP_SLICE<w+0x740>()
    MAIN_LOOP_SLICE<w+0x720>()
    MAIN_LOOP_SLICE<w+0x700>()
    MAIN_LOOP_SLICE<w+0x6e0>()
    MAIN_LOOP_SLICE<w+0x6c0>()
    MAIN_LOOP_SLICE<w+0x6a0>()
    MAIN_LOOP_SLICE<w+0x680>()
    MAIN_LOOP_SLICE<w+0x660>()
    MAIN_LOOP_SLICE<w+0x640>()
    MAIN_LOOP_SLICE<w+0x620>()
    MAIN_LOOP_SLICE<w+0x600>()
    MAIN_LOOP_SLICE<w+0x5e0>()
    MAIN_LOOP_SLICE<w+0x5c0>()
    MAIN_LOOP_SLICE<w+0x5a0>()
    MAIN_LOOP_SLICE<w+0x580>()
    MAIN_LOOP_SLICE<w+0x560>()
    MAIN_LOOP_SLICE<w+0x540>()
    MAIN_LOOP_SLICE<w+0x520>()
    MAIN_LOOP_SLICE<w+0x500>()
    MAIN_LOOP_SLICE<w+0x4e0>()
    MAIN_LOOP_SLICE<w+0x4c0>()
    MAIN_LOOP_SLICE<w+0x4a0>()
    MAIN_LOOP_SLICE<w+0x480>()
    MAIN_LOOP_SLICE<w+0x460>()
    MAIN_LOOP_SLICE<w+0x440>()
    MAIN_LOOP_SLICE<w+0x420>()
    MAIN_LOOP_SLICE<w+0x400>()
    MAIN_LOOP_SLICE<w+0x3e0>()
    MAIN_LOOP_SLICE<w+0x3c0>()
    MAIN_LOOP_SLICE<w+0x3a0>()
    MAIN_LOOP_SLICE<w+0x380>()
    MAIN_LOOP_SLICE<w+0x360>()
    MAIN_LOOP_SLICE<w+0x340>()
    MAIN_LOOP_SLICE<w+0x320>()
    MAIN_LOOP_SLICE<w+0x300>()
    MAIN_LOOP_SLICE<w+0x2e0>()
    MAIN_LOOP_SLICE<w+0x2c0>()
    MAIN_LOOP_SLICE<w+0x2a0>()
    MAIN_LOOP_SLICE<w+0x280>()
    MAIN_LOOP_SLICE<w+0x260>()
    MAIN_LOOP_SLICE<w+0x240>()
    MAIN_LOOP_SLICE<w+0x220>()
    MAIN_LOOP_SLICE<w+0x200>()
    MAIN_LOOP_SLICE<w+0x1e0>()
    MAIN_LOOP_SLICE<w+0x1c0>()
    MAIN_LOOP_SLICE<w+0x1a0>()
    MAIN_LOOP_SLICE<w+0x180>()
    MAIN_LOOP_SLICE<w+0x160>()
    MAIN_LOOP_SLICE<w+0x140>()
    MAIN_LOOP_SLICE<w+0x120>()
    MAIN_LOOP_SLICE<w+0x100>()
    MAIN_LOOP_SLICE<w+0xe0>()
    MAIN_LOOP_SLICE<w+0xc0>()
    MAIN_LOOP_SLICE<w+0xa0>()
    MAIN_LOOP_SLICE<w+0x80>()
    MAIN_LOOP_SLICE<w+0x60>()
    MAIN_LOOP_SLICE<w+0x40>()
    MAIN_LOOP_SLICE<w+0x20>()
    MAIN_LOOP_SLICE<w+0x00>()
}
#define MAIN_LOOP = takes(6) returns(0) {
    // on the stack we will have.....
    // z y x w i p 2p 3p table wnafMask
    // i = iterator that points to memory of current wnaf entry
    // w = wnaf word
    // z y x = current accumulated elliptic curve point
 main_loop_start:
    DOUBLE_MAIN<dup5,dup6>()
    
    // get i and also decrease i by 0x20 for next pass
    0x20 dup5 sub swap4 // i z y x i' p 2p 3p
    mload               // w z y x i' p 2p 3p
    dup1 add_points_start jumpi
// nothing to add       // w z y x i' p 2p 3p table wnafmask
        pop
        // note, using 'sub' instead of eq iszero. TODO: check if this can cause problems!
        dup4 0x140 sub main_loop_start jumpi
        main_loop_end jump
add_points_start:       // w z y x i' p 2p 3p table wnafMask
    dup10 and returndatasize mstore         // z y x i' p 2p 3p table wnafmask
add_points_next:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
    returndatasize mload add_points_next jumpi // z y x w i' p 2p 3p
    dup4 0x140 sub main_loop_start jumpi

main_loop_end:  // looks like we've finished
    // z y x 
}


/// @dev performs scalar multiplication for two affine points
#define MAIN_FULL = takes(0) returns(0) {
    // point table starts at 0x20
    // for two points, table will end at 0x1020
    // store globalZ at 0x1020
    // wnaf table starts at 0x1040
    // 0x00 - 0x40 = P1
    // 0x40 - 0x80 = P2
    // 0x80 - 0xa0 = s1
    // 0xa0 - 0xc0 = s2
    COMPUTE_WNAFS()

    WNAF_MASK()
    0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
    3P()
    2P()
    P()

    BETA() BETA_LOCATION() mstore // p 2p 3p
    dup3 3P_LOCATION() mstore
    dup2 2P_LOCATION() mstore
    // calculate precomputed table
    PRECOMPUTE_TABLE_FULL()
    FIND_FIRST_ENTRY()

    // 1020 stores the location we called mstore8 on, for the largest wnaf index (m)
    // 0x1020 mload div 0x20 mul // (m / 0x20) * 0x20
    returndatasize mload 0x100 mstore // store globalZ in 0x100

    // this should be i - the memory index with the largest nonzero wnaf
    dup1 mload                  // w i p 2p 3p table wnafmask
    dup7 and
    // get coordinates of first point
    returndatasize mstore
    GET_P2_LOCATION()   // o_y o_x i p 2p 3p
    mload swap1 mload   // x y i p 2p 3p
    dup4 sub swap1      // y x i p 2p 3p
    dup4 sub            // y x i p 2p 3p
    0x01                // z y x i p 2p 3p

    MAIN_LOOP_STATIC<0x160>()
    /*
    0x00 mload get_first_entry jumpi
        begin_festivities jump
get_first_entry:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
    0x00 mload get_first_entry jumpi // z y x w i' p 2p 3p
    // (this assumes we have two wnaf entries for each point respectively)
begin_festivities:
    swap3 0x20 swap1 sub swap3
    dup4 0x140 eq skip_main_loop jumpi
    MAIN_LOOP()             // zf yf xf i p 2p 3p 
skip_main_loop:
*/
// Finished with main loop. Final thing to do is scale the point's z-coordinate by the precomputed table's globalZ coordinate
    0x100 mload            // z zf yf xf i p 2p 3p 
    dup6 swap2 mulmod       // z'' yf xf i p 2p 3p
    0x40 mstore             // yf xf i p 2p 3p
    dup4 swap1 mod          // yf xf i p 2p 3p
    dup4 sub                // y xf i p 2p 3p
    0x20 mstore             // xf i p 2p 3p
    dup3 swap1 mod          // x i p 2p 3p
    returndatasize mstore             // i p 2p 3p
    pop pop pop pop pop pop
    0x60 returndatasize return
}

/*
/// @dev performs scalar multiplication for two affine points
#define MAIN_FULL = takes(0) returns(0) {
    // point table starts at 0x20
    // for two points, table will end at 0x1020
    // store globalZ at 0x1020
    // wnaf table starts at 0x1040
    // 0x00 - 0x40 = P1
    // 0x40 - 0x80 = P2
    // 0x80 - 0xa0 = s1
    // 0xa0 - 0xc0 = s2
    COMPUTE_WNAFS()

    WNAF_MASK()
    0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
    3P()
    2P()
    P()

    // calculate precomputed table
    PRECOMPUTE_TABLE_FULL()
    FIND_FIRST_ENTRY()
    // 1020 stores the location we called mstore8 on, for the largest wnaf index (m)
    // 0x1020 mload div 0x20 mul // (m / 0x20) * 0x20
    0x00 mload 0x100 mstore // store globalZ in 0x100

    // this should be i - the memory index with the largest nonzero wnaf
    dup1 mload                  // w i p 2p 3p table wnafmask
    dup7 and
    // get coordinates of first point
    0x00 mstore
    GET_P2_LOCATION()   // o_y o_x i p 2p 3p
    mload swap1 mload   // x y i p 2p 3p
    dup4 sub swap1      // y x i p 2p 3p
    dup4 sub            // y x i p 2p 3p
    0x01                // z y x i p 2p 3p
    0x00 mload get_first_entry jumpi
        begin_festivities jump
get_first_entry:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
    0x00 mload get_first_entry jumpi // z y x w i' p 2p 3p
    // (this assumes we have two wnaf entries for each point respectively)
begin_festivities:
    swap3 0x20 swap1 sub swap3
    dup4 0x140 eq skip_main_loop jumpi
    MAIN_LOOP()             // zf yf xf i p 2p 3p 
skip_main_loop:

// Finished with main loop. Final thing to do is scale the point's z-coordinate by the precomputed table's globalZ coordinate
    0x100 mload            // z zf yf xf i p 2p 3p 
    dup6 swap2 mulmod       // z'' yf xf i p 2p 3p
    0x40 mstore             // yf xf i p 2p 3p
    dup4 swap1 mod          // yf xf i p 2p 3p
    dup4 sub                // y xf i p 2p 3p
    0x20 mstore             // xf i p 2p 3p
    dup3 swap1 mod          // x i p 2p 3p
    0x00 mstore             // i p 2p 3p
    pop pop pop pop pop pop
    0x60 0x00 return
}*/