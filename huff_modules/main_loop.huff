#include "constants.huff"
#include "wnaf.huff"
#include "precompute_table.huff"
#include "double.huff"
#include "add.huff"

#define macro GET_P_30 = takes(0) returns(0) {
    0x5a dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_29 = takes(0) returns(0) {
    0x58 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_28 = takes(0) returns(0) {
    0x56 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_27 = takes(0) returns(0) {
    0x54 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_26 = takes(0) returns(0) {
    0x52 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_25 = takes(0) returns(0) {
    0x50 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_24 = takes(0) returns(0) {
    0x4e dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_23 = takes(0) returns(0) {
    0x4c dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_22 = takes(0) returns(0) {
    0x4a dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}


#define macro GET_P_21 = takes(0) returns(0) {
    0x48 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_20 = takes(0) returns(0) {
    0x46 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_19 = takes(0) returns(0) {
    0x44 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_18 = takes(0) returns(0) {
    0x42 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_17 = takes(0) returns(0) {
    0x40 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}
// p t1 p z1 -y1 x1 i
#define macro GET_P_16 = takes(0) returns(0) {
    0x3e dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_15 = takes(0) returns(0) {
    0x3c dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_14 = takes(0) returns(0) {
    0x3a dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_13 = takes(0) returns(0) {
    0x38 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_12 = takes(0) returns(0) {
    0x36 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_11 = takes(0) returns(0) {
    0x34 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_10 = takes(0) returns(0) {
    0x32 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_9 = takes(0) returns(0) {
    0x30 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_8 = takes(0) returns(0) {
    0x2e dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_7 = takes(0) returns(0) {
    0x2c dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_6 = takes(0) returns(0) {
    0x2a dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_5 = takes(0) returns(0) {
    0x28 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_4 = takes(0) returns(0) {
    0x26 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_3 = takes(0) returns(0) {
    0x24 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

#define macro GET_P_2 = takes(0) returns(0) {
    0x22 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}
// ? ? ? z y x i
#define macro GET_P_1 = takes(0) returns(0) {
    0x20 dup8 sub mload 0x02ffe0 and
    dup1 0x20 add
}

// #define macro jumptable MAIN__JUMP_TABLE {
//     alt_add_0 alt_add_1 alt_add_2 alt_add_3 alt_add_4 alt_add_5 alt_add_6 alt_add_7
//     alt_add_8 alt_add_9 alt_add_10 alt_add_11 alt_add_12 alt_add_13 alt_add_14 alt_add_15
//     alt_add_final_0 alt_add_final_1 alt_add_final_2 alt_add_final_3 alt_add_final_4 alt_add_final_5 alt_add_final_6 alt_add_final_7
//     alt_add_final_8 alt_add_final_9 alt_add_final_10 alt_add_final_11 alt_add_final_12 alt_add_final_13 alt_add_final_14 alt_add_final_15
// }

#define macro MAIN__INIT_JUMP_TABLE = takes(0) returns(0) {
    // __tableStart(MAIN__JUMP_TABLE)
    // __tableSize(MAIN_JUMP_TABLE)
    alt_add_0 0x00 mstore
    alt_add_1 0x20 mstore
    alt_add_2 0x40 mstore
    alt_add_3 0x60 mstore
    alt_add_4 0x80 mstore
    alt_add_5 0xa0 mstore
    alt_add_6 0xc0 mstore
    alt_add_7 0xe0 mstore
    alt_add_8 0x100 mstore
    alt_add_9 0x120 mstore
    alt_add_10 0x140 mstore
    alt_add_11 0x160 mstore
    alt_add_12 0x180 mstore
    alt_add_13 0x1a0 mstore
    alt_add_14 0x1c0 mstore
    alt_add_15 0x1e0 mstore
    alt_add_16 0x200 mstore
    alt_add_final_0 0x220 mstore
    alt_add_final_1 0x240 mstore
    alt_add_final_2 0x260 mstore
    alt_add_final_3 0x280 mstore
    alt_add_final_4 0x2a0 mstore
    alt_add_final_5 0x2c0 mstore
    alt_add_final_6 0x2e0 mstore
    alt_add_final_7 0x300 mstore
    alt_add_final_8 0x320 mstore
    alt_add_final_9 0x340 mstore
    alt_add_final_10 0x360 mstore
    alt_add_final_11 0x380 mstore
    alt_add_final_12 0x3a0 mstore
    alt_add_final_13 0x3c0 mstore
    alt_add_final_14 0x3e0 mstore
    alt_add_final_15 0x400 mstore
    alt_add_final_16 0x420 mstore
}
// start here
//          |
//          v
#define macro ALTERNATIVE_MAIN_LOOP = takes(0) returns(0) {
    // start by computing every point's endomorphism-split windowed-non-adjacent-form representation.
    // Get this out of the way first so we can free up the memory this thing needs for its jump table
    WNAF_GREEDY__SIZE_OF_ENTRY()
    WNAF_GREEDY__COMPUTE()
    // Set up our stack state. We need the order of the group that the bn128 curve's point coordinates are members of.
    // (this is p)
    // We also need 2p and 3p, because we avoid performing a modular reduction in intermediate sums when the result
    // still fits into an evm word. When we compute inversions of these 'overloaded' points we need to scale p by
    // an equivalent amount.
    // start by negating the size of our wnaf entry, it's more useful in this form
    // because we'll be subtracting it from our pointer to the next wnaf entry.
    // (the `add` opcode doesn't care about variable ordering on the stack, `sub` does.
    //    so whenever possible it's usually more efficient to add negative values than
    //    subtract positive ones)
    0 sub
    3P()
    2P()
    P()
    // Stack state: p 2p 3p d

    // Set up our memory state. The precomputed lookup table requires 'beta', the cube root of unity mod p.
 
    // Because we need this value when the state of our stack is somewhat undefined (hon hon), we keep it in memory.
    // We do the same with 2p, 3p for the same reasons
    BETA() BETA_LOCATION() mstore // p 2p 3p d
    dup3 3P_LOCATION() mstore
    dup2 2P_LOCATION() mstore

    // Next, let's compute our point lookup table.
    PRECOMPUTE_TABLE_FULL()

    // Nice. now, put the global-z coordinate on the stack, we want to re-use that memory
    // ...(TODO, optimize memory map)
    GLOBAL_Z_LOCATION() mload // z p 2p 3p d

    // we also want the pointer to the most significant non-zero wnaf entry on the stack
    WNAF_GREEDY__FIND_FIRST_ENTRY<dup5,dup6>()
    
    // The next step is to fiddle with the *least* significant wnaf entry. 
    // We want this entry to point to a location in the jump table that will terminate
    // the algorithm. We can do this by adding 34 (max number of points *2 + 2) to the entry
    WNAF_START_LOCATION() mload 0x22 add WNAF_START_LOCATION() mstore
    // Next, we set up our jump table.
    // TODO: upgrade Huff parser so that we can store this in bytecode and just use codecopy

    MAIN__INIT_JUMP_TABLE()
    // The stack state is now: i Z p 2p 3p
    // We now want to get the first point in our wnaf entry and set that as our
    // initial point
    dup1 mload                  // n i z p 2p 3p
    dup2 sub                    // o i z p 2p 3p d
    // the wnaf entries are located 30 + (size of wnaf) bytes behind the location of 'n'
    0x1e dup8 sub add           // o' i z p 2p 3p d
    mload
    // entry should now be in least significant 2 bytes
    0x02ffe0 and                // o_x
    dup1 mload                  // -x o_x i z p 2p 3p
    dup5 sub                    // x o_x i z p 2p 3p
    swap1 0x20 add mload        // -y x i z p 2p 3p
    dup5 sub                    // y x i z p 2p 3p
    0x01                        // z y x i p 2p 3p

    // the next step is to update i to point to the next (offset) index,
                                // z y x i z p 2p 3p
    0x20                        // 32 z y x i z p 2p 3p d
    dup5                        // i 32 z y x i z p 2p 3p d
    dup11 add
    swap5
    mload
    0x04 shl
    sub
    mload jump

    /*
    // next, we want to use the number of entries at this wnaf index as
    // an index to our lookup table, but offset by 1 (0x20) because we have already
    // fished a point out of the wnaf entry.
    mload 0x04 shl sub
    // and finally we can load up this jump entry and jump into our main loop
    mload jump */

    // jump destinations for our main loop. Each destination 'falls through' to the next
    // destination, so we only need 16 copies of the 'add' algorithm
    alt_add_16:
        ADD_MAIN<GET_P_16, dup6, dup7>()
    alt_add_15:
        ADD_MAIN<GET_P_15, dup6, dup7>()
    alt_add_14:
        ADD_MAIN<GET_P_14, dup6, dup7>()
    alt_add_13:
        ADD_MAIN<GET_P_13, dup6, dup7>()
    alt_add_12:
        ADD_MAIN<GET_P_12, dup6, dup7>()
    alt_add_11:
        ADD_MAIN<GET_P_11, dup6, dup7>()
    alt_add_10:
        ADD_MAIN<GET_P_10, dup6, dup7>()
    alt_add_9:
        ADD_MAIN<GET_P_9, dup6, dup7>()
    alt_add_8:
        ADD_MAIN<GET_P_8, dup6, dup7>()
    alt_add_7:
        ADD_MAIN<GET_P_7, dup6, dup7>()
    alt_add_6:
        ADD_MAIN<GET_P_6, dup6, dup7>()
    alt_add_5:
        ADD_MAIN<GET_P_5, dup6, dup7>()
    alt_add_4:
        ADD_MAIN<GET_P_4, dup6, dup7>()
    alt_add_3:
        ADD_MAIN<GET_P_3, dup6, dup7>()
    alt_add_2:
        ADD_MAIN<GET_P_2, dup6, dup7>()
    alt_add_1:
        ADD_MAIN<GET_P_1, dup6, dup7>()
    alt_add_0:
        // double the accumulator once there's nothing left to add
        DOUBLE_MAIN<dup6, dup7>()
        // stack state: z y x i Z p 2p 3p d
        // Next up, we want to decrease i by the size of a wnaf entry in memory.
        // We then want to load up the next wnaf index and jump.
        // (the pointer i points to the next wnaf entry, so we're decreasing
        //    the *next* wnaf pointer, not the current one. This saves a swap op)
        dup9 dup5 add swap4
        mload
        // Once we have the wnaf entry, we need to convert to a jump index.
        // The entry is equal to the number of points * 2 (to shave two opcodes from the wnaf algo).
        // So we can shift this by 4 bits to turn into a memory index.
        // (there are a lot of different ways to do this, still trying to find the most efficient,
        //    storing the jump table as packed 2-byte values saves no opcodes because
        //    we replace a bit shift with a mask, but it does make the raw table a lot smaller)
        0x04 shl
        mload
        jump

    // We have a separate instantiation of the 'loop' for the final entry in our wnaf. This is because
    // we don't want to double the accumulator at the end of this section.
    alt_add_final_16:
        ADD_MAIN<GET_P_16, dup6, dup7>()
    alt_add_final_15:
        ADD_MAIN<GET_P_15, dup6, dup7>()
    alt_add_final_14:
        ADD_MAIN<GET_P_14, dup6, dup7>()
    alt_add_final_13:
        ADD_MAIN<GET_P_13, dup6, dup7>()
    alt_add_final_12:
        ADD_MAIN<GET_P_12, dup6, dup7>()
    alt_add_final_11:
        ADD_MAIN<GET_P_11, dup6, dup7>()
    alt_add_final_10:
        ADD_MAIN<GET_P_10, dup6, dup7>()
    alt_add_final_9:
        ADD_MAIN<GET_P_9, dup6, dup7>()
    alt_add_final_8:
        ADD_MAIN<GET_P_8, dup6, dup7>()
    alt_add_final_7:
        ADD_MAIN<GET_P_7, dup6, dup7>()
    alt_add_final_6:
        ADD_MAIN<GET_P_6, dup6, dup7>()
    alt_add_final_5:
        ADD_MAIN<GET_P_5, dup6, dup7>()
    alt_add_final_4:
        ADD_MAIN<GET_P_4, dup6, dup7>()
    alt_add_final_3:
        ADD_MAIN<GET_P_3, dup6, dup7>()
    alt_add_final_2:
        ADD_MAIN<GET_P_2, dup6, dup7>()
    alt_add_final_1:
        ADD_MAIN<GET_P_1, dup6, dup7>()
    alt_add_final_0:
    // We're almost done now. We have our result, but we need to scale the final
    // point's Z-coordinate by the globalZ coordinate, as we performed the
    // entire scalar multiplication algorithm on an isomorphism of the bn128 curve
    // where globalZ is considered affine.
    // Our accumulator also represents the y-coordinate in its inverse form,
    // so we need to invert it.
    // Finally, both x and y are probably overloaded so we need to perform a modular reduction
        dup5                    // z zf yf xf i Z p 2p 3p 
        dup7 swap2 mulmod       // z'' yf xf i Z p 2p 3p
        0x40 mstore             // yf xf i Z p 2p 3p
        dup5 swap1 mod          // yf xf i Z p 2p 3p
        dup5 sub                // y xf i Z p 2p 3p
        0x20 mstore             // xf i Z p 2p 3p
        dup4 swap1 mod          // x i Z p 2p 3p
        returndatasize mstore   // i Z p 2p 3p
    // Might as well clean up the stack, it's only 12 gas.
        pop pop pop pop pop pop
    // and we're done! Let's get out of here...
        0x60 returndatasize return
}

// w i p t1 p z1 -y1 x1 p 2p 3p table
/// @dev use wnaf table to get the memory location of a point, and update wnaf table
#define macro GET_P2_LOCATION = takes(0) returns(0) {
    returndatasize mload      // w
    // we want to get a byte index of our wnaf table that is non-zero
    // we don't want to iterate over every byte, because that's slow!
    // instead we isolate the least significant set bit of t.
    // We know that non-zero wnaf entries are aligned at byte boundaries because we stored them via mstore8
    // we also know that every wnaf entry is odd. Ipso facto, if we isolate the least significant bit of w
    // then that bit corresponds to the first bit in a byte that contains a non-zero wnaf entry

    dup1 returndatasize sub               // -w w
    dup2 and                    // b w
    // next up, is to calculate the index of the byte in 'b' that is nonzero.
    // In WNAF, we used a lookup table to calculate this, but because we are testing the byte index here and not the bit index we can be more efficient.
    // (credit to Recmo Bloemen for showing me this trick).
    // use b as the divisor against literal 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f.
    // because b only has one bit set, and that bit is the 1st bit of a byte, this acts like a bit-shift operation on the literal.
    // which will place our desired byte index in the least significant byte, which we can mask off
    0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f div 0xff and // x w

    // we want to clear the wnaf entry at byte index 'b' (for future iterations)
    returndatasize dup2 mstore8 // that'll do it.

    // now what we have our wnaf byte index, we can use it for two purposes
    // 1: access the relevant byte in 'w' that contains our wnaf entry
    // 2: calculate the memory offset where our point is stored
    // point lookup tables take 32 words of memory per point (excluding endomorphism)
    // which equals precisely 1kb (0x400)
    swap1 // w x
    dup2 0x400 mul // o w x
    swap2 byte // points start at 0x1060, so we need to add 0x1040 into result

    0x20 mul add POINT_TABLE_START_LOCATION_MINUS_32() add // o_x

    dup1 0x20 add // o_y o_x
}

// b w p t1 p z1 -y1 x1 p 2p 3p table
/// @dev use wnaf table to get the memory location of a point, and update wnaf table
#define macro GET_P2_LOCATION_LOOP = takes(0) returns(0) {
    returndatasize mload      // w
    // we want to get a byte index of our wnaf table that is non-zero
    // we don't want to iterate over every byte, because that's slow!
    // instead we isolate the least significant set bit of t.
    // We know that non-zero wnaf entries are aligned at byte boundaries because we stored them via mstore8
    // we also know that every wnaf entry is odd. Ipso facto, if we isolate the least significant bit of w
    // then that bit corresponds to the first bit in a byte that contains a non-zero wnaf entry

    dup1 returndatasize sub               // -w w
    dup2 and                    // b w
    // next up, is to calculate the index of the byte in 'b' that is nonzero.
    // In WNAF, we used a lookup table to calculate this, but because we are testing the byte index here and not the bit index we can be more efficient.
    // (credit to Recmo Bloemen for showing me this trick).
    // use b as the divisor against literal 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f.
    // because b only has one bit set, and that bit is the 1st bit of a byte, this acts like a bit-shift operation on the literal.
    // which will place our desired byte index in the least significant byte, which we can mask off
    dup13 div 0xff and // x w

    // we want to clear the wnaf entry at byte index 'b' (for future iterations)
    returndatasize dup2 mstore8 // that'll do it.

    // now what we have our wnaf byte index, we can use it for two purposes
    // 1: access the relevant byte in 'w' that contains our wnaf entry
    // 2: calculate the memory offset where our point is stored
    // point lookup tables take 32 words of memory per point (excluding endomorphism)
    // which equals precisely 1kb (0x400)
    swap1 // w x
    dup2 0x0a shl // mul // o w x
    // dup2 0x400 mul // o w x
    swap2 byte // points start at 0x1060, so we need to add 0x1040 into result

    0x05 shl add POINT_TABLE_START_LOCATION_MINUS_32() add // o_x

    dup1 0x20 add // o_y o_x
}

template <wnafLocation>
#define macro MAIN_LOOP_SLICE = takes(10) returns(10) {
    DOUBLE_MAIN<dup5, dup6>()
    <wnafLocation> mload iszero add_skip jumpi
    <wnafLocation> mload dup10 and returndatasize mstore
add_points_next:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
jumpdest
    returndatasize mload add_points_next jumpi
add_skip:
}

// original algorithm. A bit less efficient and the bytecode size is about 7kb too big.
// Could fix in a few ways but the greedy algorithm is faster anyways. Leaving it around
// for testing and comparison purposes.
template <w>
#define macro MAIN_LOOP_STATIC = takes(0) returns(0) {
    // now let's figure out where we need to jump to
    // so if i = 0x1140 then we start at the very top
    // and if i = 0x160 we skip straight to the end
    // z y x i p 2p 3p
    0x20 dup5 WNAF_END_LOCATION() sub div   // jump distance
    __codesize(MAIN_LOOP_SLICE<0x1000>) mul
    hmm add jump
    // // first loop iteration
    // DOUBLE_MAIN<dup5, dup6>()
    // <wStart> mload dup1 add_points_start jumpi
    // pop add_skip jump
jumpdest
    dup10 and returndatasize mstore
add_points_next:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
hmm:
    returndatasize mload add_points_next jumpi
jumpdest

    MAIN_LOOP_SLICE<w+0xfc0>()
    MAIN_LOOP_SLICE<w+0xfa0>()
    MAIN_LOOP_SLICE<w+0xf80>()
    MAIN_LOOP_SLICE<w+0xf60>()
    MAIN_LOOP_SLICE<w+0xf40>()
    MAIN_LOOP_SLICE<w+0xf20>()
    MAIN_LOOP_SLICE<w+0xf00>()
    MAIN_LOOP_SLICE<w+0xee0>()
    MAIN_LOOP_SLICE<w+0xec0>()
    MAIN_LOOP_SLICE<w+0xea0>()
    MAIN_LOOP_SLICE<w+0xe80>()
    MAIN_LOOP_SLICE<w+0xe60>()
    MAIN_LOOP_SLICE<w+0xe40>()
    MAIN_LOOP_SLICE<w+0xe20>()
    MAIN_LOOP_SLICE<w+0xe00>()
    MAIN_LOOP_SLICE<w+0xde0>()
    MAIN_LOOP_SLICE<w+0xdc0>()
    MAIN_LOOP_SLICE<w+0xda0>()
    MAIN_LOOP_SLICE<w+0xd80>()
    MAIN_LOOP_SLICE<w+0xd60>()
    MAIN_LOOP_SLICE<w+0xd40>()
    MAIN_LOOP_SLICE<w+0xd20>()
    MAIN_LOOP_SLICE<w+0xd00>()
    MAIN_LOOP_SLICE<w+0xce0>()
    MAIN_LOOP_SLICE<w+0xcc0>()
    MAIN_LOOP_SLICE<w+0xca0>()
    MAIN_LOOP_SLICE<w+0xc80>()
    MAIN_LOOP_SLICE<w+0xc60>()
    MAIN_LOOP_SLICE<w+0xc40>()
    MAIN_LOOP_SLICE<w+0xc20>()
    MAIN_LOOP_SLICE<w+0xc00>()
    MAIN_LOOP_SLICE<w+0xbe0>()
    MAIN_LOOP_SLICE<w+0xbc0>()
    MAIN_LOOP_SLICE<w+0xba0>()
    MAIN_LOOP_SLICE<w+0xb80>()
    MAIN_LOOP_SLICE<w+0xb60>()
    MAIN_LOOP_SLICE<w+0xb40>()
    MAIN_LOOP_SLICE<w+0xb20>()
    MAIN_LOOP_SLICE<w+0xb00>()
    MAIN_LOOP_SLICE<w+0xae0>()
    MAIN_LOOP_SLICE<w+0xac0>()
    MAIN_LOOP_SLICE<w+0xaa0>()
    MAIN_LOOP_SLICE<w+0xa80>()
    MAIN_LOOP_SLICE<w+0xa60>()
    MAIN_LOOP_SLICE<w+0xa40>()
    MAIN_LOOP_SLICE<w+0xa20>()
    MAIN_LOOP_SLICE<w+0xa00>()
    MAIN_LOOP_SLICE<w+0x9e0>()
    MAIN_LOOP_SLICE<w+0x9c0>()
    MAIN_LOOP_SLICE<w+0x9a0>()
    MAIN_LOOP_SLICE<w+0x980>()
    MAIN_LOOP_SLICE<w+0x960>()
    MAIN_LOOP_SLICE<w+0x940>()
    MAIN_LOOP_SLICE<w+0x920>()
    MAIN_LOOP_SLICE<w+0x900>()
    MAIN_LOOP_SLICE<w+0x8e0>()
    MAIN_LOOP_SLICE<w+0x8c0>()
    MAIN_LOOP_SLICE<w+0x8a0>()
    MAIN_LOOP_SLICE<w+0x880>()
    MAIN_LOOP_SLICE<w+0x860>()
    MAIN_LOOP_SLICE<w+0x840>()
    MAIN_LOOP_SLICE<w+0x820>()
    MAIN_LOOP_SLICE<w+0x800>()
    MAIN_LOOP_SLICE<w+0x7e0>()
    MAIN_LOOP_SLICE<w+0x7c0>()
    MAIN_LOOP_SLICE<w+0x7a0>()
    MAIN_LOOP_SLICE<w+0x780>()
    MAIN_LOOP_SLICE<w+0x760>()
    MAIN_LOOP_SLICE<w+0x740>()
    MAIN_LOOP_SLICE<w+0x720>()
    MAIN_LOOP_SLICE<w+0x700>()
    MAIN_LOOP_SLICE<w+0x6e0>()
    MAIN_LOOP_SLICE<w+0x6c0>()
    MAIN_LOOP_SLICE<w+0x6a0>()
    MAIN_LOOP_SLICE<w+0x680>()
    MAIN_LOOP_SLICE<w+0x660>()
    MAIN_LOOP_SLICE<w+0x640>()
    MAIN_LOOP_SLICE<w+0x620>()
    MAIN_LOOP_SLICE<w+0x600>()
    MAIN_LOOP_SLICE<w+0x5e0>()
    MAIN_LOOP_SLICE<w+0x5c0>()
    MAIN_LOOP_SLICE<w+0x5a0>()
    MAIN_LOOP_SLICE<w+0x580>()
    MAIN_LOOP_SLICE<w+0x560>()
    MAIN_LOOP_SLICE<w+0x540>()
    MAIN_LOOP_SLICE<w+0x520>()
    MAIN_LOOP_SLICE<w+0x500>()
    MAIN_LOOP_SLICE<w+0x4e0>()
    MAIN_LOOP_SLICE<w+0x4c0>()
    MAIN_LOOP_SLICE<w+0x4a0>()
    MAIN_LOOP_SLICE<w+0x480>()
    MAIN_LOOP_SLICE<w+0x460>()
    MAIN_LOOP_SLICE<w+0x440>()
    MAIN_LOOP_SLICE<w+0x420>()
    MAIN_LOOP_SLICE<w+0x400>()
    MAIN_LOOP_SLICE<w+0x3e0>()
    MAIN_LOOP_SLICE<w+0x3c0>()
    MAIN_LOOP_SLICE<w+0x3a0>()
    MAIN_LOOP_SLICE<w+0x380>()
    MAIN_LOOP_SLICE<w+0x360>()
    MAIN_LOOP_SLICE<w+0x340>()
    MAIN_LOOP_SLICE<w+0x320>()
    MAIN_LOOP_SLICE<w+0x300>()
    MAIN_LOOP_SLICE<w+0x2e0>()
    MAIN_LOOP_SLICE<w+0x2c0>()
    MAIN_LOOP_SLICE<w+0x2a0>()
    MAIN_LOOP_SLICE<w+0x280>()
    MAIN_LOOP_SLICE<w+0x260>()
    MAIN_LOOP_SLICE<w+0x240>()
    MAIN_LOOP_SLICE<w+0x220>()
    MAIN_LOOP_SLICE<w+0x200>()
    MAIN_LOOP_SLICE<w+0x1e0>()
    MAIN_LOOP_SLICE<w+0x1c0>()
    MAIN_LOOP_SLICE<w+0x1a0>()
    MAIN_LOOP_SLICE<w+0x180>()
    MAIN_LOOP_SLICE<w+0x160>()
    MAIN_LOOP_SLICE<w+0x140>()
    MAIN_LOOP_SLICE<w+0x120>()
    MAIN_LOOP_SLICE<w+0x100>()
    MAIN_LOOP_SLICE<w+0xe0>()
    MAIN_LOOP_SLICE<w+0xc0>()
    MAIN_LOOP_SLICE<w+0xa0>()
    MAIN_LOOP_SLICE<w+0x80>()
    MAIN_LOOP_SLICE<w+0x60>()
    MAIN_LOOP_SLICE<w+0x40>()
    MAIN_LOOP_SLICE<w+0x20>()
    MAIN_LOOP_SLICE<w+0x00>()
}
#define macro MAIN_LOOP = takes(6) returns(0) {
    // on the stack we will have.....
    // z y x w i p 2p 3p table wnafMask
    // i = iterator that points to memory of current wnaf entry
    // w = wnaf word
    // z y x = current accumulated elliptic curve point
 main_loop_start:
    DOUBLE_MAIN<dup5,dup6>()
    
    // get i and also decrease i by 0x20 for next pass
    0x20 dup5 sub swap4 // i z y x i' p 2p 3p
    mload               // w z y x i' p 2p 3p
    dup1 add_points_start jumpi
// nothing to add       // w z y x i' p 2p 3p table wnafmask
        pop
        // note, using 'sub' instead of eq iszero. TODO: check if this can cause problems!
        dup4 0x140 sub main_loop_start jumpi
        main_loop_end jump
add_points_start:       // w z y x i' p 2p 3p table wnafMask
    dup10 and returndatasize mstore         // z y x i' p 2p 3p table wnafmask
add_points_next:
    ADD_MAIN<GET_P2_LOCATION_LOOP,dup5,dup6>()
    returndatasize mload add_points_next jumpi // z y x w i' p 2p 3p
    dup4 0x140 sub main_loop_start jumpi

main_loop_end:  // looks like we've finished
    // z y x 
}


/// @dev performs scalar multiplication for two affine points
#define macro MAIN_FULL = takes(0) returns(0) {
    // point table starts at 0x20
    // for two points, table will end at 0x1020
    // store globalZ at 0x1020
    // wnaf table starts at 0x1040
    // 0x00 - 0x40 = P1
    // 0x40 - 0x80 = P2
    // 0x80 - 0xa0 = s1
    // 0xa0 - 0xc0 = s2
    WNAF_JUMP_TABLE__COMPUTE()

    WNAF_MASK()
    0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
    3P()
    2P()
    P()

    BETA() BETA_LOCATION() mstore // p 2p 3p
    dup3 3P_LOCATION() mstore
    dup2 2P_LOCATION() mstore
    // calculate precomputed table
    PRECOMPUTE_TABLE_FULL()
    FIND_FIRST_ENTRY()

    // 1020 stores the location we called mstore8 on, for the largest wnaf index (m)
    // 0x1020 mload div 0x20 mul // (m / 0x20) * 0x20
    returndatasize mload 0x100 mstore // store globalZ in 0x100

    // this should be i - the memory index with the largest nonzero wnaf
    dup1 mload                  // w i p 2p 3p table wnafmask
    dup7 and
    // get coordinates of first point
    returndatasize mstore
    GET_P2_LOCATION()   // o_y o_x i p 2p 3p
    mload swap1 mload   // x y i p 2p 3p
    dup4 sub swap1      // y x i p 2p 3p
    dup4 sub            // y x i p 2p 3p
    0x01                // z y x i p 2p 3p

    MAIN_LOOP_STATIC<WNAF_START_LOCATION>()

// Finished with main loop. Final thing to do is scale the point's z-coordinate by the precomputed table's globalZ coordinate
    0x100 mload            // z zf yf xf i p 2p 3p 
    dup6 swap2 mulmod       // z'' yf xf i p 2p 3p
    0x40 mstore             // yf xf i p 2p 3p
    dup4 swap1 mod          // yf xf i p 2p 3p
    dup4 sub                // y xf i p 2p 3p
    0x20 mstore             // xf i p 2p 3p
    dup3 swap1 mod          // x i p 2p 3p
    returndatasize mstore             // i p 2p 3p
    pop pop pop pop pop pop
    0x60 returndatasize return
}
