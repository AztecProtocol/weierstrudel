#include "precompute_table_single.huff"
#include "constants.huff"

// TODO put these all in one place
#define GLOBAL_Z = takes(0) returns(1) { 0x00 }

// initial stack state is: dz3 dz2 y x p
// final stack is dz3 dz2 p
template <x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE_15_TRANSITION = takes(5) returns(0) {
    // TODO, could rewrite macros to remove these 2 swap ops
    swap2   // y dz2 dz3 x p
    dup5 swap1  // y p dz2 dz3 x p
    dup4 mulmod // y' dz2 dz3 x p
    dup1 <yNeg> mstore
    dup1 <yEndo> mstore
    dup5 sub dup1 <y> mstore
    <yEndoNeg> mstore // dz2 dz3 x p
    swap2 dup4 swap1 // x p dz3 dz2 p
    dup4 mulmod // x' dz3 dz2 p
    dup4 sub    // -x' dz3 dz2 p
    dup4 dup2 BETA() mulmod
    dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore
}


// expected stack state is: y x
// final stack state is null
template <p1,p2,x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE_15 = takes(3) returns(0) {
    <p1> swap1 mod
    dup1 <yNeg> mstore
    dup1 <yEndo> mstore
    <p1> sub dup1 <y> mstore
    <yEndoNeg> mstore
    <p2> swap1 mod
    <p2> sub
    <p2> dup2 BETA() mulmod dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore
}

// p1 is at dup2
// p2 is at dup4
// expected stack state = dz2 p dz3 p y x
// final stack state    = dz3 dz2
template <p1,x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE_13 = takes(7) returns(0) {
    swap5
    // x p dz3 p y dx2
    dup6
    // dz2 x p dz3 p y dz2
    mulmod
    // x' dz3 p y dz
    dup3 sub
    dup3 dup2 BETA() mulmod
    dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore
    // p dz3 p y dz2
    swap2
    // y p dz3 dz2
    dup3 mulmod
    // y' dz3 dz2 p
    dup1 <yNeg> mstore
    dup1 <yEndo> mstore
    <p1> sub dup1 <y> mstore
    <yEndoNeg> mstore // dz3 dz2 p dz2' p p dz3' p y x
}

// expected stack state = dz3 dz2 p dz2' p p dz3' p y x
// final stack state    = dz3'' dz2''
template <p1,x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE = takes(10) returns(2) {
    swap3 mulmod                // dz2'' dz3 p p dz3' p y x
    swap4 mulmod                // dz3'' p dz2'' p y x
    swap4 dup5 mulmod           // y' dz2'' p dz3'' x
    dup1 <yNeg> mstore
    dup1 <yEndo> mstore
    dup3 sub
    dup1 <y> mstore
    <yEndoNeg> mstore           // dz2'' p dz3'' x
    swap3 dup4 mulmod           // x' dz3'' dz2''
    <p1> sub                    // -x' dz3'' dz2''
    <p1> BETA() dup3 mulmod     // -betax -x dz3'' dz2''
    dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore               // dz3'' dz2''
}

#define PRECOMPUTE_TABLE_ONE = takes(0) returns(0) {
    0x00 calldataload
    0x20 calldataload
    PRECOMPUTE_TABLE_SINGLE_AFFINE_FINAL()
    0x60 mstore pop
    // stack state  : -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    RESCALE_15<dup4,dup3,0x2c0,0x2e0,0x300,0x320,0x6c0,0x6e0,0x700,0x720>()
    // stack state  : dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=11}^{n=3} y_1 x_1
    RESCALE_13<dup4,0x280,0x2a0,0x340,0x360,0x680,0x6a0,0x740,0x760>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x240,0x260,0x380,0x3a0,0x640,0x660,0x780,0x7a0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x200,0x220,0x3c0,0x3e0,0x600,0x620,0x7c0,0x7e0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0x1c0,0x1e0,0x400,0x420,0x5c0,0x5e0,0x800,0x820>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0x180,0x1a0,0x440,0x460,0x580,0x5a0,0x840,0x860>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x140,0x160,0x480,0x4a0,0x540,0x560,0x880,0x8a0>()
    // stack state  : dz^3' dz^2' p dz_3^2 p p dz_3^3 p -y_1 x_1
    RESCALE<P,0x100,0x120,0x4c0,0x4e0,0x500,0x520,0x8c0,0x8e0>()
    // stack state  : dz^3' dz^2'
}

// assume calldata map of:
// 0x00 - 0x20: X1
// 0x20 - 0x40: Y1
// 0x40 - 0x60: X2
// 0x60 - 0x80: Y2
#define PRECOMPUTE_TABLE_TWO = takes(0) returns(0) {
    // somehow we need an affine point on the stack.
    // Is this where we should start using calldata?
    0x00 calldataload
    0x20 calldataload
    PRECOMPUTE_TABLE_SINGLE_AFFINE()

    // after precompute_table_affine, the stack state is
    // z15 y15 x15 ... blah
    // We want to scale our new point by z15
    // So we need to calculate X2*Z15*Z15 and Y2*Z15*Z15*Z15
    // we would scale up Z2 by Z15, but as Z2 = 1

    // stack state  : z15 (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=15}^{n=3} y_1 x_1

                            // z -y x p
    dup1 dup5 dup1 dup1 dup1         // p p p p z z -y x p
    dup5 dup1 mulmod       // zz p p p z z
    dup2 dup2 0x40 calldataload // x zz p zz p p z
    mulmod                 // x' zz p p p z z
    swap5 mulmod           // zzz p p x' z
    0x60 calldataload mulmod // y p x z (dz^2 p p dz^3)
                           // shoudn't this be y x p dz^2 p p dz^3???
    PRECOMPUTE_TABLE_SINGLE_FINAL()
    // stack state  : z_15 p -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    // need to rescale z. should have p at stack position 5
    0x00 mstore // TODO hardcode?
    pop
    // stack state  : p -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    RESCALE_15<dup4,dup3,0x1e0,0x200,0x220,0x240,0x5e0,0x600,0x620,0x640>()
    // stack state  : dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=11}^{n=3} y_1 x_1
    RESCALE_13<dup4,0x1a0,0x1c0,0x260,0x280,0x5a0,0x5c0,0x660,0x680>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x160,0x180,0x2a0,0x2c0,0x560,0x580,0x6a0,0x6c0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x120,0x140,0x2e0,0x300,0x520,0x540,0x6e0,0x700>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0xe0,0x100,0x320,0x340,0x4e0,0x500,0x720,0x740>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0xa0,0xc0,0x360,0x380,0x4a0,0x4c0,0x760,0x780>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x60,0x80,0x3a0,0x3c0,0x460,0x480,0x7a0,0x7c0>()
    // stack state  : dz^3' dz^2' p dz_3^2 p p dz_3^3 p -y_1 x_1
    RESCALE<dup6,0x20,0x40,0x3e0,0x400,0x420,0x440,0x7e0,0x800>()
    // stack state  : dz^3' dz^2' p d.z^2 p d.z^3 -y_15 x_15 (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=13}^{n=3}
    swap3 mulmod // dz^2 dz^3' p d.z^3
    swap3 mulmod // dz^3 dz^2 -y_15 x_15
    RESCALE_15_TRANSITION<0x9e0,0xa00,0xa20,0xa40,0xde0,0xe00,0xe20,0xe40>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=13}^{n=3}
    RESCALE<dup4,0x9a0,0x9c0,0xa60,0xa80,0xda0,0xdc0,0xe60,0xe80>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x960,0x980,0xaa0,0xac0,0xd60,0xd80,0xea0,0xec0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x920,0x940,0xae0,0xb00,0xd20,0xd40,0xee0,0xf00>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0x8e0,0x900,0xb20,0xb40,0xce0,0xd00,0xf20,0xf40>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0x8a0,0x8c0,0xb60,0xb80,0xca0,0xcc0,0xf60,0xf80>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x860,0x880,0xba0,0xbc0,0xc60,0xc80,0xfa0,0xfc0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=1}^{n=3}
    RESCALE<P,0x820,0x840,0xbe0,0xc00,0xc20,0xc40,0xfe0,0x1000>()
    // dz^3' dz^2'
    // 0x1020 0x00 return
    // 0x820 mload
    // 0x840 mload
    // 0x00 mload
    // 0x40 mstore
    // 0x20 mstore
    // 0x00 mstore
    // 0x00 0x60 mstore
    // 0x80 0x00 return
}



/*
// input: z
// output: y x z
template<p1,X_CALLDATA,Y_CALLDATA>
#define RESCALE_INPUT_POINT = takes(4) returns(3) {
    dup1 <p1> dup1 dup1         // p p p z
    dup4 dup1 mulmod            // zz p p z
    dup2 dup2 <X_CALLDATA> calldataload // x zz p p z
    mulmod
}
*/

// assume calldata map of:
// 0x00 - 0x20: X1
// 0x20 - 0x40: Y1
// 0x40 - 0x60: X2
// 0x60 - 0x80: Y2
#define PRECOMPUTE_TABLE_FULL = takes(0) returns(0) {

precompute_table_start:
    // loop over all but last point
    PRECOMPUTE_TABLE_SINGLE()
    0x00 mload precompute_table_start jumpi

    RESCALE_15<dup4,dup3,0x1e0,0x200,0x220,0x240,0x5e0,0x600,0x620,0x640>()
    RESCALE_13<dup4,0x1a0,0x1c0,0x260,0x280,0x5a0,0x5c0,0x660,0x680>()
    RESCALE<dup4,0x160,0x180,0x2a0,0x2c0,0x560,0x580,0x6a0,0x6c0>()
    RESCALE<dup4,0x120,0x140,0x2e0,0x300,0x520,0x540,0x6e0,0x700>()
    RESCALE<dup4,0xe0,0x100,0x320,0x340,0x4e0,0x500,0x720,0x740>()
    RESCALE<dup4,0xa0,0xc0,0x360,0x380,0x4a0,0x4c0,0x760,0x780>()
    RESCALE<dup4,0x60,0x80,0x3a0,0x3c0,0x460,0x480,0x7a0,0x7c0>()
    RESCALE<dup6,0x20,0x40,0x3e0,0x400,0x420,0x440,0x7e0,0x800>()
}

#define PRECOMPUTE_TABLE_TWO_MODIFIED = takes(0) returns(0) {
    // somehow we need an affine point on the stack.
    // Is this where we should start using calldata?
    0x00 calldataload
    0x20 calldataload
    PRECOMPUTE_TABLE_SINGLE_AFFINE()

    // after precompute_table_affine, the stack state is
    // z15 y15 x15 ... blah
    // We want to scale our new point by z15
    // So we need to calculate X2*Z15*Z15 and Y2*Z15*Z15*Z15
    // we would scale up Z2 by Z15, but as Z2 = 1

    // stack state  : z15 (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=15}^{n=3} y_1 x_1

    // z -y x p
    dup1 dup5 dup1 dup1             // p p p z z -y x p
    dup4 dup1 mulmod                // zz p p z z -y x p
    dup2 dup2 0x40 calldataload     // x zz p zz p p z z -y x p
    mulmod                          // x' zz p p z z -y x p
    swap4 mulmod                    // zzz p x' z -y x p
    0x60 calldataload mulmod        // y x z (-yold xold p)

    PRECOMPUTE_TABLE_SINGLE_FINAL_B()
    // stack state  : z_15 p -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    // need to rescale z. should have p at stack position 5
    0x00 mstore // TODO hardcode?
    pop // TODO OPTIMIZE THIS OUT
    // (idea: in the final add-and-rescale iteration, we end up with z p y. instead have z y p x p. can wind into rescale_15)
    // stack state  : -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    RESCALE_15<dup4,dup3,0x1e0,0x200,0x220,0x240,0x5e0,0x600,0x620,0x640>()
    // stack state  : dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=11}^{n=3} y_1 x_1
    RESCALE_13<dup4,0x1a0,0x1c0,0x260,0x280,0x5a0,0x5c0,0x660,0x680>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x160,0x180,0x2a0,0x2c0,0x560,0x580,0x6a0,0x6c0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x120,0x140,0x2e0,0x300,0x520,0x540,0x6e0,0x700>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0xe0,0x100,0x320,0x340,0x4e0,0x500,0x720,0x740>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0xa0,0xc0,0x360,0x380,0x4a0,0x4c0,0x760,0x780>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x60,0x80,0x3a0,0x3c0,0x460,0x480,0x7a0,0x7c0>()
    // stack state  : dz^3' dz^2' p dz_3^2 p p dz_3^3 p -y_1 x_1
    RESCALE<dup6,0x20,0x40,0x3e0,0x400,0x420,0x440,0x7e0,0x800>()
    // stack state  : dz^3' dz^2' p d.z^2 p d.z^3 -y_15 x_15 (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=13}^{n=3}
    swap3 mulmod // dz^2 dz^3' p d.z^3
    swap3 mulmod // dz^3 dz^2 -y_15 x_15
    RESCALE_15_TRANSITION<0x9e0,0xa00,0xa20,0xa40,0xde0,0xe00,0xe20,0xe40>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=13}^{n=3}
    RESCALE<dup4,0x9a0,0x9c0,0xa60,0xa80,0xda0,0xdc0,0xe60,0xe80>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x960,0x980,0xaa0,0xac0,0xd60,0xd80,0xea0,0xec0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x920,0x940,0xae0,0xb00,0xd20,0xd40,0xee0,0xf00>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0x8e0,0x900,0xb20,0xb40,0xce0,0xd00,0xf20,0xf40>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0x8a0,0x8c0,0xb60,0xb80,0xca0,0xcc0,0xf60,0xf80>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x860,0x880,0xba0,0xbc0,0xc60,0xc80,0xfa0,0xfc0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=1}^{n=3}
    RESCALE<P,0x820,0x840,0xbe0,0xc00,0xc20,0xc40,0xfe0,0x1000>()
    // dz^3' dz^2'
    // 0x1020 0x00 return
    // 0x820 mload
    // 0x840 mload
    // 0x00 mload
    // 0x40 mstore
    // 0x20 mstore
    // 0x00 mstore
    // 0x00 0x60 mstore
    // 0x80 0x00 return
}
// what is the memory map?
// P  3P  5P  7P  9P  11P  13P  15P  -15P  -13P  -11P -9P -7P -5P -3P -P
// 0  40  80  c0 100  140  180  1c0  200   240   280  2c0 300 340 380 3c0

