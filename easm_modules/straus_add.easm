#include "./easm_modules/constants.easm"
/// @dev mixed point addition for our precomputed point table algorithm
/// @notice expects (z1 -y1 x1) to be on stack
/// expects (-x2) to be at memory index mx2 and (y2) at my2
/// p1, p2, p3 represent opcodes to get prime field moduli
/// (sometimes there's one lurking further down the stack we can grab)
/// initial stack state: z y x

template <p1,p2,p3,mx2,my2>
#define STRAUS_ADD = takes(3) returns(11) {
    <p1>
    dup2 dup1 mulmod
    // zz z y x
    <p2>
    dup1 dup1 dup4 dup6 mulmod
    // zzz p p zz z y x
    <my2> mload mulmod
    // t2 p zz z y x
    dup5 add
    // t2 p zz z y x
    swap2
    // zz p t2 z y x
    <mx2> mload mulmod
    // t1 t2 z y x
    dup5
    // x t1 t2 z y x
    add
    // t1 t2 z y x
    dup1 <p3> eq reject jumpi
    <p3>
    dup1 dup3 dup1 mulmod
    // t3 p t1 t2 z y x
    dup2 dup2 dup5 mulmod
    // t4 t3 p t1 t2 z y x
    swap4
    // t2 t3 p t1 t4 z y x
    dup3 dup3 dup10 mulmod
    // t5 t2 t3 p t1 t4 z y x
    dup4 sub
    dup4 dup1 dup1 dup5 dup1 mulmod
    // x3 p p t5 t2 t3 p t1 t4 z y x
    dup4 dup1 add add
    dup9 addmod
    // x3 p t5 t2 t3 p t1 t4 z y x
    swap2
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup3 add
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup2 swap4
    // t2 t5 p x3 p t3 p t1 t4 z y x
    mulmod
    // y3 x3 p t3 p t1 t4 z y x
    dup3 dup8 dup11 mulmod
    // t6 y3 x3 p t3 p t1 t4 z y x
    add
    2P() sub
    // -y3 x3 p t3 p t1 t4 z y x
    dup3 dup1
    // p p y3 x3 p t3 p t1 t4 z y x
    swap7
    // t1 p y3 x3 p t3 p p t4 z y x
    dup2
    // p t1 p y3 x3 p t3 p p t4 z y x
    swap10
    // z t1 p y3 x3 p t3 p p t4 p y x
    mulmod
    // z3 y3 x3 p t3 p p t4 p y x

    reject_skip jump // todo optimize this out
    reject:
        0x00 0x00 revert
    reject_skip:
}