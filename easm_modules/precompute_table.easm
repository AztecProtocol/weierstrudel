#include "./easm_modules/precompute_table_single.easm"
#include "./easm_modules/constants.easm"

// TODO put these all in one place
#define GLOBAL_Z = takes(0) returns(1) { 0x60 }

// initial stack state is: dz3 dz2 y x p
// final stack is dz3 dz2 p
template <x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE_15_TRANSITION = takes(5) returns(0) {
    // TODO, could rewrite macros to remove these 2 swap ops
    swap2   // y dz2 dz3 x p
    dup5 swap1  // y p dz2 dz3 x p
    dup4 mulmod // y' dz2 dz3 x p
    dup1 <y> mstore
    dup1 <yEndo> mstore
    dup5 sub dup1 <yNeg> mstore
    <yEndoNeg> mstore // dz2 dz3 x p
    swap2 dup4 swap1 // x p dz3 dz2 p
    dup4 mulmod // x' dz3 dz2 p
    dup4 dup2 BETA() mulmod
    dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore
}

// expected stack state is: y x
// final stack state is null
template <p1,p2,x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE_15 = takes(3) returns(0) {
    dup1 <y> mstore
    dup1 <yEndo> mstore
    <p1> sub dup1 <yNeg> mstore
    <yEndoNeg> mstore
    <p2> dup2 BETA() mulmod dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore
}

// p1 is at dup2
// p2 is at dup4
// expected stack state = dz2 p dz3 p y x
// final stack state    = dz3 dz2
template <p1,x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE_13 = takes(7) returns(0) {
    swap5
    // x p dz3 p y dx2
    dup6
    // dz2 x p dz3 p y dz2
    mulmod
    // x' dz3 p y dz
    dup3 dup2 BETA() mulmod
    dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore
    // p dz3 p y dz2
    swap2
    // y p dz3 dz2
    dup3 mulmod
    // y' dz3 dz2 p
    dup1 <y> mstore
    dup1 <yEndo> mstore
    <p1> sub dup1 <yNeg> mstore
    <yEndoNeg> mstore // dz3 dz2 p dz2' p p dz3' p y x
}

// expected stack state = dz3 dz2 p dz2' p p dz3' p y x
// final stack state    = dz3'' dz2''
template <p1,x,y,xNeg,yNeg,xEndo,yEndo,xEndoNeg,yEndoNeg>
#define RESCALE = takes(10) returns(0) {
    swap3 mulmod                // dz2'' dz3 p p dz3' p y x
    swap4 mulmod                // dz3'' p dz2'' p y x
    swap4 dup5 mulmod           // y' dz2'' p dz3'' x
    dup1 <y> mstore
    dup1 <yEndo> mstore
    dup3 sub
    dup1 <yNeg> mstore
    <yEndoNeg> mstore           // dz2'' p dz3'' x
    swap3 dup4 mulmod           // x' dz3'' dz2''
    <p1> BETA() dup3 mulmod     // betax x dz3'' dz2''
    dup1 <xEndo> mstore
    <xEndoNeg> mstore
    dup1 <x> mstore
    <xNeg> mstore               // dz3'' dz2''
}


#define PRECOMPUTE_TABLE_ONE = takes(0) returns(0) {
    0x00 calldataload
    0x20 calldataload
    PRECOMPUTE_TABLE_SINGLE_AFFINE_FINAL()
    GLOBAL_Z() mstore pop
    // stack state  : -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    RESCALE_15<dup3,dup2,0x2c0,0x2e0,0x300,0x320,0x6c0,0x6e0,0x700,0x720>()
    // stack state  : dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=11}^{n=3} y_1 x_1
    RESCALE_13<dup4,0x280,0x2a0,0x340,0x360,0x680,0x6a0,0x740,0x760>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x240,0x260,0x380,0x3a0,0x640,0x660,0x780,0x7a0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x200,0x220,0x3c0,0x3e0,0x600,0x620,0x7c0,0x7e0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0x1c0,0x1e0,0x400,0x420,0x5c0,0x5e0,0x800,0x820>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0x180,0x1a0,0x440,0x460,0x580,0x5a0,0x840,0x860>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x140,0x160,0x480,0x4a0,0x540,0x560,0x880,0x8a0>()
    // stack state  : dz^3' dz^2' p dz_3^2 p p dz_3^3 p -y_1 x_1
    RESCALE<P,0x100,0x120,0x4c0,0x4e0,0x500,0x520,0x8c0,0x8e0>()
    // stack state  : dz^3' dz^2'
}

// assume calldata map of:
// 0x00 - 0x20: X1
// 0x20 - 0x40: Y1
// 0x40 - 0x60: X2
// 0x60 - 0x80: Y2
#define PRECOMPUTE_TABLE_TWO = takes(0) returns(0) {
    // somehow we need an affine point on the stack.
    // Is this where we should start using calldata?
    0x00 calldataload
    0x20 calldataload
    PRECOMPUTE_TABLE_SINGLE_AFFINE()

    // after precompute_table_affine, the stack state is
    // z15 y15 x15 ... blah
    // We want to scale our new point by z15
    // So we need to calculate X2*Z15*Z15 and Y2*Z15*Z15*Z15
    // we would scale up Z2 by Z15, but as Z2 = 0

    // stack state  : z15 (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=15}^{n=3} y_1 x_1

                            // z -y x p
    dup1 dup5 dup1 dup1 dup1         // p p p p z z -y x p
    dup5 dup1 mulmod       // zz p p p z z
    dup2 dup2 0x40 calldataload // x zz p zz p p z
    mulmod                 // x' zz p p p z z
    swap5 mulmod           // zzz p p x' z
    0x60 calldataload mulmod // y p x z (dz^2 p p dz^3)
                           // shoudn't this be y x p dz^2 p p dz^3???
    PRECOMPUTE_TABLE_SINGLE_FINAL()
    // stack state  : z_15 p -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    // need to rescale z. should have p at stack position 5
    GLOBAL_Z() mstore
    pop // TODO OPTIMIZE THIS OUT
    // stack state  : -y_15 x_15 dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=13}^{n=3} y_1 x_1
    RESCALE_15<dup3,dup2,0x2c0,0x2e0,0x300,0x320,0xac0,0xae0,0xb00,0xb20>()
    // stack state  : dz_15^2 p dz_15^3 p (-y_i x_i p dz_i^2 p p dz_i^3 p)_{i=11}^{n=3} y_1 x_1
    RESCALE_13<dup4,0x280,0x2a0,0x340,0x360,0xa80,0xaa0,0xb40,0xb60>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x240,0x260,0x380,0x3a0,0xa40,0xa60,0xb80,0xba0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x200,0x220,0x3c0,0x3e0,0xa00,0xa20,0xbc0,0xbe0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0x1c0,0x1e0,0x400,0x420,0x9c0,0x9e0,0xc00,0xc20>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0x180,0x1a0,0x440,0x460,0x980,0x9a0,0xc40,0xc60>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x140,0x160,0x480,0x4a0,0x940,0x960,0xc80,0xca0>()
    // stack state  : dz^3' dz^2' p dz_3^2 p p dz_3^3 p -y_1 x_1
    RESCALE<dup6,0x100,0x120,0x4c0,0x4e0,0x900,0x920,0xcc0,0xce0>()
    // stack state  : dz^3' dz^2' -y_15 x_15 (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=13}^{n=3}

    RESCALE_15_TRANSITION<0x6c0,0x6e0,0x700,0x720,0xec0,0xee0,0xf00,0xf20>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=13}^{n=3}
    RESCALE<dup4,0x680,0x6a0,0x740,0x760,0xe80,0xea0,0xf40,0xf60>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=11}^{n=3}
    RESCALE<dup4,0x640,0x660,0x780,0x7a0,0xe40,0xe60,0xf80,0xfa0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=9}^{n=3}
    RESCALE<dup4,0x600,0x620,0x7c0,0x7e0,0xe00,0xe20,0xfc0,0xfe0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=7}^{n=3}
    RESCALE<dup4,0x5c0,0x5e0,0x800,0x820,0xdc0,0xde0,0x1000,0x1020>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=5}^{n=3}
    RESCALE<dup4,0x580,0x5a0,0x840,0x860,0xd80,0xda0,0x1040,0x1060>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=3}^{n=3}
    RESCALE<dup4,0x540,0x560,0x880,0x8a0,0xd40,0xd60,0x1080,0x10a0>()
    // stack state  : dz^3' dz^2' (p dz_i^2 p p dzi^3 p -y_(i-1) x_(i-1))_{i=1}^{n=3}
    RESCALE<P,0x500,0x520,0x8c0,0x8e0,0xd00,0xd20,0x10c0,0x10e0>()
    // dz^3' dz^2'
}


// what is the memory map?
// P  3P  5P  7P  9P  11P  13P  15P  -15P  -13P  -11P -9P -7P -5P -3P -P
// 0  40  80  c0 100  140  180  1c0  200   240   280  2c0 300 340 380 3c0

