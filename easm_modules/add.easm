#include "./easm_modules/constants.easm"

/// @dev mixed point addition
/// @notice expects (z1 -y1 x1) to be on stack
template <getX2,getY2,p>
#define ADD = takes(4) returns(4) {
    <p>
    dup2 dup1 mulmod
    // zz z y x
    <p>
    dup1 dup1 dup4 dup6 mulmod
    // zzz p p zz z y x
    <getY2> mulmod
    // t2 p zz z y x
    dup5 add
    // t2 p zz z y x
    swap2
    // zz p t2 z y x
    <getX2> mulmod
    // t1 t2 z y x
    dup5
    // x t1 t2 z y x
    add
    // t1 t2 z y x
    dup1 <p> eq reject jumpi
    <p>
    dup1 dup3 dup1 mulmod
    // t3 p t1 t2 z y x
    dup2 dup2 dup5 mulmod
    // t4 t3 p t1 t2 z y x
    swap4
    // t2 t3 p t1 t4 z y x
    dup3 dup3 dup10 mulmod
    // t5 t2 t3 p t1 t4 z y x
    dup4 sub
    dup4 dup1 dup1 dup5 dup1 mulmod
    // x3 p p t5 t2 t3 p t1 t4 z y x
    dup4 dup1 add add
    dup9 addmod
    // x3 p t5 t2 t3 p t1 t4 z y x
    swap2
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup3 add
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup2 swap4
    // t2 t5 p x3 p t3 p t1 t4 z y x
    mulmod
    // y3 x3 p t3 p t1 t4 z y x
    dup3 dup8 dup11 mulmod
    // t6 y3 x3 p t3 p t1 t4 z y x
    add
    43776485743678550444492811490514550177392622314595647325378075789290452417166 sub
    // -y3 x3 p t3 p t1 t4 z y x
    dup3 dup1
    // p p y3 x3 p t3 p t1 t4 z y x
    swap7
    // t1 p y3 x3 p t3 p p t4 z y x
    dup2
    // p t1 p y3 x3 p t3 p p t4 z y x
    swap10
    // z t1 p y3 x3 p t3 p p t4 p y x
    mulmod
    // z3 y3 x3 p t3 p p t4 p y x
}

// initial state y x
template <mx2,my2>
#define ADD_AFFINE = takes(4) returns(11) {   
    P() <my2> mload dup3 add
    // t2 p y x
    <mx2> mload dup5 add
    // t1 t2 p y x
    dup3 dup1 dup3 dup1 mulmod
    // t3 p t1 t2 p y x
    dup1 add_affine_skip jumpi
        0x00 0x00 revert
    add_affine_skip:
    dup2 dup2 dup5 mulmod
    // t4 t3 p t1 t2 p y x
    swap4
    // t2 t3 p t1 t4 p y x
    dup3 dup3 dup10 mulmod
    // t5 t2 t3 p t1 t4 p y x
    dup4 sub dup4 dup1 dup1 dup5 dup1 mulmod
    // x3 p p t5 t2 t3 p t1 t4 p y x
    dup4 dup1 add add dup9 addmod
    // x3 p t5 t2 t3 p t1 t4 p y x
    swap2
    // t5 p x3 t2 t3 p t1 t4 p y x
    dup3 add
    // t5 p x3 t2 t3 p t1 t4 p y x
    dup2 swap4 mulmod
    // y3 x3 p t3 p t1 t4 p y x
    dup3 dup8 dup11 mulmod
    // t6 y3 x3 p t3 p t1 t4 p y x
    add
    2P() sub
    // -y3 x3 p t3 p t1 t4 p y x
    dup3
    // p y3 x3 p t3 p t1 t4 p y x
    swap6
    // z3 y3 x3 p t3 p p t4 p y x
}

/// @dev mixed point addition for our precomputed point table algorithm
/// @notice expects (z1 -y1 x1) to be on stack
/// expects (-x2) to be at memory index mx2 and (y2) at my2
/// p1, p2, p3 represent opcodes to get prime field moduli
/// (sometimes there's one lurking further down the stack we can grab)
/// initial stack state: z y x
template <p1,p2,p3,mx2,my2>
#define PRECOMPUTE_TABLE_ADD = takes(3) returns(11) {
    <p1>
    dup2 dup1 mulmod
    // zz z y x
    <p2>
    dup1 dup1 dup4 dup6 mulmod
    // zzz p p zz z y x
    <my2> mload mulmod
    // t2 p zz z y x
    dup5 add
    // t2 p zz z y x
    swap2
    // zz p t2 z y x
    <mx2> mload mulmod
    // t1 t2 z y x
    dup5
    // x t1 t2 z y x
    add
    // t1 t2 z y x
    <p3> dup1 dup3 dup1 mulmod
    // We want to figure out if X2Z1Z1 - X1 = 0
    // i.e. does t1 = 0?
    // We cannot test t1 directly as doubling overloads x by 2x, and addition overloads x by 3x.
    // So t1 can be either 0, p or 2p. Instead we check if t3 = t1*t1 is zero.
    // As t3 is the output of a mulmod opcode it is not overloaded.
    // We also save some gas by testing if t3 is anything but 0 - our jump condition is just t3
    // t3 p t1 t2 z y x
    dup1 skip_reject jumpi
        0x00 0x00 revert
    skip_reject:
    dup2 dup2 dup5 mulmod
    // t4 t3 p t1 t2 z y x
    swap4
    // t2 t3 p t1 t4 z y x
    dup3 dup3 dup10 mulmod
    // t5 t2 t3 p t1 t4 z y x
    dup4 sub
    dup4 dup1 dup1 dup5 dup1 mulmod
    // x3 p p t5 t2 t3 p t1 t4 z y x
    dup4 dup1 add add
    dup9 addmod
    // x3 p t5 t2 t3 p t1 t4 z y x
    swap2
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup3 add
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup2 swap4
    // t2 t5 p x3 p t3 p t1 t4 z y x
    mulmod
    // y3 x3 p t3 p t1 t4 z y x
    dup3 dup8 dup11 mulmod
    // t6 y3 x3 p t3 p t1 t4 z y x
    add
    2P() sub
    // -y3 x3 p t3 p t1 t4 z y x
    dup3 dup1
    // p p y3 x3 p t3 p t1 t4 z y x
    swap7
    // t1 p y3 x3 p t3 p p t4 z y x
    dup2
    // p t1 p y3 x3 p t3 p p t4 z y x
    swap10
    // z t1 p y3 x3 p t3 p p t4 p y x
    mulmod
    // z3 y3 x3 p t3 p p t4 p y x
}


template <p1,p2,p3,mx2,my2,mz2>
#define PRECOMPUTE_TABLE_ADD_AND_RESCALE = takes(3) returns(11) {
    <p1> // p z y x
    dup2 dup1 mulmod
    <p2> // zz z y x
    dup1 dup1 dup4 dup6 mulmod
    // zzz p p zz z y x
    <my2> mload mulmod
    // t2 p zz z y x
    dup5 add
    // t2 p zz z y x
    swap2
    // zz p t2 z y x
    <mx2> mload mulmod
    // t1 t2 z y x
    dup5
    // x t1 t2 z y x
    add
    // t1 t2 z y x
    <p3> dup1 dup3 dup1 mulmod
    dup1 skip_reject jumpi
        0x00 0x00 revert
    skip_reject:
    // t3 p t1 t2 z y x
    dup2 dup2 dup5 mulmod
    // t4 t3 p t1 t2 z y x
    swap4
    // t2 t3 p t1 t4 z y x
    dup3 dup3 dup10 mulmod
    // t5 t2 t3 p t1 t4 z y x
    dup4 sub
    dup4 dup1 dup1 dup5 dup1 mulmod
    // x3 p p t5 t2 t3 p t1 t4 z y x
    dup4 dup1 add add
    dup9 addmod
    // x3 p t5 t2 t3 p t1 t4 z y x
    swap2
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup3 add
    // t5 p x3 t2 t3 p t1 t4 z y x
    dup2 swap4
    // t2 t5 p x3 p t3 p t1 t4 z y x
    mulmod
    // y3 x3 p t3 p t1 t4 z y x
    dup3 dup8 dup11 mulmod
    // t6 y3 x3 p t3 p t1 t4 z y x
    add
    2P() sub
    // -y3 x3 p t3 p t1 t4 z y x
    dup3 dup1 dup1
    // p p p y3 x3 p t3 p t1 t4 z y x
    swap8
    // t1 p p y3 x3 p t3 p p t4 z y x
    dup2
    // p t1 p p y3 x3 p t3 p p t4 z y x
    swap11
    // z t1 p p y3 x3 p t3 p p t4 p y x
    mulmod
    // z3 p y3 x3 p t3 p p t4 p y x
    <mz2> mload mulmod
    // z3 y3 x3 p t3 p p t4 p y x
}

// output stack state = z3 p y3 x3 dz2 p p dz3 p y x
template <p1,p2,p3,p4,p5,p6,mx2,my2,mz2>
#define PRECOMPUTE_TABLE_ADD_AND_RESCALE_FINAL = takes(3) returns(11) {
    <p1>
    dup2 dup1 mulmod
    // zz z y x
    <p2>
    dup1 dup1 dup4 dup6 mulmod
    // zzz p p zz z y x
    <my2> mload mulmod
    // t2 p zz z y x
    dup5 add
    // t2 p zz z y x
    swap2
    // zz p t2 z y x
    <mx2> mload mulmod
    // t1 t2 z y x
    dup5
    // x t1 t2 z y x
    add
    // t1 t2 z y x
    <p3> dup2 dup1 mulmod
    dup1 skip_reject jumpi
        0x00 0x00 revert
    skip_reject:
    // t3 t1 t2 z y x
    <p4> dup2 dup4 mulmod // depth 7
    // t4 t3 t1 t2 z y x
    swap3
    // t2 t3 t1 t4 z y x
    <p5> dup1 dup4 dup10 mulmod // depth 8
    // t5 p t2 t3 t1 t4 z y x
    dup2 sub
    dup2 dup1 dup5 dup1 mulmod
    // x3 p t5 p t2 t3 t1 t4 z y x
    dup3 dup1 add add
    dup8 addmod
    // x3 t5 p t2 t3 t1 t4 z y x
    swap3 swap1
    // t5 t2 p x3
    dup4 add
    // t5 t2 p x3
    mulmod
    // y3 x3 t3 t1 t4 z y x // depth 9
    <p6> dup6 dup9 mulmod
    // t6 y3 x3 t3 t1 t4 z y x
    add
    2P() sub
    // -y3 x3 t3 t1 t4 z y x
    <p6> dup1 dup1 dup1 // depth 9
    // p p p p y3 x3 t3 t1 t4 z y x
    swap7
    // t1 p p p y3 x3 t3 p t4 z y x
    dup2
    // p t1 p p p y3 x3 t3 p t4 z y x
    swap10
    // z t1 p p p y3 x3 t3 p t4 p y x
    mulmod
    // z3 p p y3 x3 p t3 p t4 p y x
    <mz2> mload mulmod
    // z3 p y3 x3 p t3 p t4 p y x
}